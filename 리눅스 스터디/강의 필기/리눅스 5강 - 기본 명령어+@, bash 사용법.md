리눅스는 운영체체 중에서도 [[kernel|커널]].

명령어를 내릴 수 있는 창 = [[shell]](bash)
bash의 경우 띄어쓰기가 중요함. 

## 리눅스 기본 명령어 Ⅱ
- pwd : 현재 위치를 절대 경로로 알고 싶을 떄
- whoami : 현재 접속 계정을 알고 싶을 때
- man ls : man page가 나옴. ls에 대한 명령어 설명이 들어가 있음.
	ls의 경우 -a과 -l을 합쳐서 -al로 쓸 수 있게 해둠. (파라미터 두 개를 연달아서)
- ls \*.c : 확장자가 c인 파일들을 출력
	\*은 정규식
- cat 파일명 : text로 된 파일을 열어볼 수 있음.(내용 출력)

bin 폴더에 있는 것들은 실행가능한 피일들. 
	bin은 binary라는 뜻. 이진의. 실행할 수 있는 파일들은 명령어들이고 그게 이진수로 이루어져있음.

. 은 숨김파일


# bash shell script
bash명령어를 쓰는 공간은 /bin/bash/에 있음. 
bash는 운영체제에 명령을 전달하는 프로그램.
간단하고 강력한 언어 for CLI user.

c언어나 파이썬은 확장자로 .c, .py

bash는 .sh

sh파일은 어떤 shell script를 쓸 건지 명시해줘야 함. 
\#!/bin/bash : bash의 위치를 알려주고, shell script 시작
- echo : 출력 명령어
	echo "hihi" : hihi 출력됨.
- sh 파일명.확장자 : 파일 실행 (파일 안에 있는 명령어들이 시행됨.)


set background=dark : vim에서 backgroud의 색에 맞춰 글자 색을 바꿀 수 있음. 
	= 이런거 띄어쓰기 안 해야 함. bash에서 띄어쓰기는 큰 의미를 가지기 때문에 프로그래밍 언어로 코딩할 떄처럼 띄어쓰기 하지 말아야 함.


### 변수
변수명=값
	자료형을 명시할 필요 x
	변수명 = 값 처럼 띄어쓰기 하면 안 됨.
	e.g, str="hello"
	echo ${str} 또는 echo $str
		sh test.sh하면 hello 출력됨.

### 조건문
기준값 > 비교값 : gt
기준값 < 비교값 : lt
기준값 = 비교값 : eq
기준값 != 비교값 :ne
기준값 >= 비교값 : ge
기준값 <= 비교값 : le

``` bash
if [조건]
	//조건은 [$# -eq 0] : 파라미터가 0과 같은지
		//-를 쓰고 조건을 써야 함.
then
	// 조건이 일치할 떄 실행.
fi
```

=> bash의 경우 예를 들어, 프로그램을 실행시킬 떄 parameter를 받을 수 있음. $0은 0번째 파라미터, $1은 1번째 파라미터, $2는 2번쨰 파라미터, 

다른 프로그래밍 기능처럼 ;를 문장의 구분으로 사용 가능. 
ls
ls -a를 
ls; ls -a로 사용 가능.

또한, 
``` bash
if [조건]; then
	// 실행문
fi
```
로 작성 가능.

### 반복문
cron : 주기마다 특정 동작을 반복시키는 것.
	 e.g., DNS IP를 5분마다 갱신해라. 

 for를 사용. (파이썬 문법과 유사)
``` bash
 for i in 1 3 5
 do
	echo $i   // 변수는 % 표시
done
```
결과 
1
3
5


``` bash
 for i in {1..20}
 do
	echo $i   // 변수는 % 표시
done
```

``` bash
 for ((i=0;i<=10;i++))  // c언어와 비슷하지만 괄호가 2개
 do
	echo $i   // 변수는 % 표시
done
```
bash 파일명.sh를 입력하면 bash 문법으로 실행한다는 의미.
결과
1
2
3
...
20까지 출력 


ls -al 입력 후 
script에 권한이 없다고 나온다면, chmod +x 파일명.sh로 권한을 줘서 실행을 해줄 수 있음.


``` bash
 for i in 'ls'
 do
	echo $i   // 변수는 % 표시
done
```
ls의 결과가 하나하나 i로 들어가게 됨.


``` bash
 for ((i=0;i<=10;i++))  
 do
	echo 'whoami'   
done
```
현재 접속 계정을 10번 출력 


``` c
// test.c
int main (int argc, char* argv[]) //argc는 명령줄에서 입력받은 인자의 개수
// argv는 그 인자들의 값을 저장한 문자열 배열
{
	for (int i=0; i<argc; i++){
		printf("%s ", argv[i]);
		}
	printf("\n");
	return 0;
}
```

``` bash
// test.sh
for ((i=0;i<10;i++))
do
	./a.out $i
done
```
파라미터를 각 반복마다 다르게 넘겨줌.


## 실습
![[Pasted image 20240429195320.png]]
Desktop 폴더로 이동 후 vim 편집기로 test.c와 test.sh 생성 후 편집

![[Pasted image 20240429200710.png|500]]
바로 ./a.out으로 실행시키려 했는데 그런 파일이나 디렉토리가 없다고 나옴.

전처리기 -> 컴파일러 -> 어셈블러 -> 링커
이 과정으로 되는 것을 GCC 하나로 모두 진행 시켜서 소스 파일을 실행 파일로 생성 시켜 주기 때문에 [[gcc]]를 이용해 먼저 컴파일 해야 한다.
**gcc를 이용해 컴파일에 성공하면 a.out이라는 파일이 생성된다.**

**gcc test.c**
![[Pasted image 20240429201016.png]]
여기서 그냥 명령어로 a.out을 입력하면 명령어를 발견할 수 없다는 오류 메시지가 나온다. 이는 a.out가 저장된 디렉토리를 path로 설정하지 않았기 때문이다. path로 설정되지 않는 디렉토리에 있는 명령어는 디렉토리 위치를 지정해주지 않는 한 실행되지 않는다.
그러므로 **./a.out로 실행한다.**
즉, 프로그램 이름 앞에 디렉토리 위치 정보인 ./를 추가해야 현재 디렉토리에 있는 명령어가 실행되는데, 여기서 마침표(.)는 현재의 디렉토리를 의미하고, 슬래시(/)는 디렉토리를 구분하는 문자다.

프로그램을 실행할 때 항상 argv[0]에는 실행 파일의 이름이 저장되므로, argv의 값은 최소 1이다.
 `for` 반복문에서 `i`가 0부터 시작하여 `argc` 미만까지 실행되기 때문에, `argv[0]` 즉, 실행 파일의 이름 `./a.out`이 출력된다.

./test.sh 로 bash 프로그램을 실행시킬 권한이 없기 때문에 위와 permission이 거부되었다고 출력되며, ls로 확인해보면 test.sh가 녹색으로 표시되어 있지 않음.
![[Pasted image 20240429204349.png]]

chmod +x test.sh로 권한을 부여하고, 다시 ls로 확인해보면 권한이 부여된 걸 확인할 수 있다.
![[Pasted image 20240429204546.png]]

./test.sh로 실행한 결과 다음과 같이 결과가 나오는 걸 확인할 수 있다.
![[Pasted image 20240429204641.png]]
1. `./test.sh` 스크립트는 반복문을 이용해 0부터 9까지의 숫자를 `./a.out` 프로그램에 인자로 전달한다.
2. 스크립트에서 `./a.out $i`라는 명령을 사용하는데, 여기서 `$i`는 반복문에서의 현재 숫자를 의미한다.
3. 이렇게 `./a.out` 프로그램을 호출할 때 마다 `argc`는 2가 되며, `argv[0]`은 `./a.out`, `argv[1]`은 각각의 숫자 (0부터 9까지)가 됩니다.
4. 프로그램 내의 `for` 반복문은 `argv[0]`과 `argv[1]`을 순서대로 출력하므로, `./a.out` 뒤에 각 숫자가 붙어서 `./a.out0`, `./a.out1`, ..., `./a.out9`가 출력되는 것이다.

**따라서 스크립트 실행 시, 각 숫자가 프로그램 인자로 추가되어 프로그램 이름과 함께 출력된다.**

test.c 코드가 변경되면 **gcc test.c**로 다시 컴파일 해주고 ./test.sh로 실행해야 변경 사항이 반영되어 실행된다.
<br>

### 참고 사이트
https://seamless.tistory.com/2


### 질문
vim은 설정 파일을 갖고 있음. 

리눅스의 대부분의 프로그램들은 설정 파일을 가지고 있음. 
CLI식 설정 파일.
문자열로 설정을 넣어주어야 함. => 설정을 외우고 있어야 함. (검색하거나)
cd .. // 홈 디렉토리에
vim vim.rc  // 해당 파일에 설정이 있음.

김태용의 쉘 스크립트 입문 책 추천.
