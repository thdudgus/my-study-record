Brute-Force design: Q. How to implement BF.
ex. 동전 2개의 모든 조합 나열.
-> for loop 구현
-> graph 탐사: DFS, BFS
=> Brute-Force는 DFS, BFS의 형태로 모든 조합을 나열한다.

ex. 미로 공원 탈출, maze problem
ex. 4-Queen problem: place 4 queens onto 4X4 chess board
Queen은 체스에서 가장 강력한 공격능력을 가지고 있음. 자신의 가로, 세로 대각선에 있는 상대를 모두 공격할 수 있음. 
![[Pasted image 20240619194045.png|150]]
=> N-Queens problem : generalization
0/1 Knapsack문제와 같이 어려운 문제로 분류됨.
DP, Greedy와 같은 방법으로 효과적으로 풀 수 없음. 따라서 새로운 접근 방법이 필요함.

==> BF의 조합 나열을 피할 수 없으니, 효과적인 조합 나열을 통해 계산량을 줄이고자 함. : Backtracking의 idea.

time complexity : ex) 8-Queens problem 64^8 : 전체적인 조합의 수
--> State-space / Search-space tree.
--> 4-Queens state-space tree
tree를 그려보면 모든 가능한 조합은 leaf node의 개수가 됨.

Idea : 모든 탐색 가능한 조합을 검사하고 나열할 필요가 있을까?

# Backtracking
1. DFS(깊이우선탐색) of a tree except that nodes are visited if promising. (ex: same row, same column, same 대각에 없음)
2. backtrack if NON-promising : Pruning.
3. (formal) **Do a DFS of a state-space tree, checking whether each node is promising, and if it is nonpromising, backtracking to the node's parent.**

### 4-Queen problem
![[Pasted image 20240619203834.png|500]]
하부 트리가 pruning되어 날라가도 답이 없다면 Q1을 1.1에서 1.2로 옮겨서 다시 해봄. 이 과정을 반복. 

design key : promising function의 설계.
- N-Queen 문제는 promising function이 명확히 주어짐.
- DP에서 binomial coefficient 문제는 recurrence equation이 주어짐. 

analysis key : 
- optimality : 답이 있으면 반드시 정답을 찾는다. trivial.
	!= efficiency
- time complexity: exponential (not polynomial time), worst case는 BF complexity와 동일하다.
- 중요성 : empirical test, 실험적 성능을 제시해야 함. (execution/run time) -> 실제 이 알고리즘이 실행됐을 때, 실제 실행시간이 중요함. 얼마나 빨리 응답을 하는가.


Q. 자식 노드를 방문하기 전에 check/계산 가능 또는 직접 방문 후 계산/check 해야 하는가?
A. 둘다 가능. -> 구현 이슈는 개발자에게 있음. 

본 강의에선 혼란 방지를 위해 '직접 방문 후 계산/check' 선택.
자식 노드 생성 후 이후의 조합이 불필요한지 검사한 걸로 구현하겠음.

backtracking 문제는 CS에서 어려운 문제에 속함.

### Backtracking (DFS) vs Bracnh-and-bound (BFS)
Backtracking (DFS) << Bracnh-and-bound (BFS) : 후자가 필드에서 많이 사용되는 인기 있는 알고리즘.

## Sum of subset problem (Subset sum problem)
a special case if 0/1 Knapsack

S = {item1, item2, ..., itemn}
weight = {weight1, weight2, ..., weightn}
W = fixes weight (given)
-> find A (a subset of S) such that the sum of weights in A (equals W) : 
부분집합 A의 weight 합이 W가 되는 A를 모두 찾아라.

응용/적용 기술 : 게임 서버 load balancing task team.
n개의 서버(item). = S
각 서버의 사용자 capacity를 동일하게 맞춤
서버가 감당할 수 있는 capacity에 user 부분집합의 capacity를 합해 서버에 맡기면 서버에 꽉 차게 됨.

example: |S| = 5, n = 5, weight = {5 6 10 11 16}, W = 21
solution: 21을 맞추는 부분 집합을 찾는다. -> multiple solutions
algorithm design -> Brute-force.
	All enumerations of possible subsets. -> for-loop << DFS
	![[Pasted image 20240619211034.png|200]]
	=> 2^n보다 빨리 찾을 수 있는 방법이 없기 때문에 해당 문제를 어렵다고 하는 것.

==> backtracking for Sum of Subset problem
design : 
step 1. promising function 설계 (더 이상 이후의 item 조합이 절대 답을 찾을 수 없다는 걸 알게 된다면  pruning)
step 2. DFS traverse/visit
![[Pasted image 20240619214102.png|400]]
말단 노드가 가능한 모든 경우의 수를 나타내게 됨. = 2^5
하나하나 다 체크하면 BF
담았더니 안 됐다면, 그 밑은 다 날릴 수도 있고, 안 담으면 안 되겠다면 그 전 부분은 날리고 진행하면 됨. Backtacking

**step1 : promising function 설계**
1) i-th level : weight + weight(i+1) > W
2) weight + 미래 총 weight 합 < W
=> 두 조건 중 하나라도 만족한다면 solution을 만들 필요가 없음. (i+1번째 item에 대한 고려가 필요 없음.)

start root S는 dummy
![[Pasted image 20240619220921.png|400]]
```
function promising(i: index)
{
	return (Boolean:T/F) promising = 1) and 2) 조건 위배 여부.
}
```
promising function수학적 표현현 => T or F return 

**step2 : DFS visit**
구현하면 됨.


### Analysis
1. optimal solution generated
2. execution time : timer. depending on promising functions
3. 실제 생성된 노드 수 == 15 / 31(total) : performance gain. BF보다 노드 생성 수에서 이득.
	또는 생성된 leaf node 수 / 전체 leaf 노드 수 계산.

Q. 앞선 예제는 item -> sorted. 만약 1) item들이 역순으로 정렬되어 있었다면? 2) item들이 random으로 입력(정렬)되었다면? : 고민해보기.
만약에 정렬하는 것이 우수하다면, 정렬은 전처리로 처리될 수 있음. 전처리(sorting)가 다소 시간이 걸리더라도, 진행하고 backtracking을 수행하는 것이 좋은 것인가?


## Graph Coloring problem
== vertex coloring problem
== m-coloring problem 
=> (difficult)

: coloring undirected graph with <= m colors (2 adjective vertices must have different colors)

응용/적용 분야 : 강의실 무선마이크, 무선 네트워크 (귀한 자원)

CS solution:
1. BF : complexity = T(n, m) = O(m^n)

Q. 어떻게 가장 작은 m을 찾나?
A. 찾을 수 없다. (efficient polynomial algorithm) (현재 학습 수준)

Q. given m (fixed), m-colorable?
A. Yes
=> backtracking for GC
**promising function**
인접한 노드들이 같은 색을 갖고 있는지 체크
![[Pasted image 20240619223408.png|400]]
정답이 도출되면 나머진 pruning

## Hamiltonian Circuits (HC) problem
== Hamiltonian path, Hamiltonian cycle problem

주어진 연결된, 방향성이 없는 그래프. HC (H.tour)
주어져 있는 출발점에서 시작해서 각각의 vertex를 정확히 한 번만 경유하여 출발점으로 돌아오는 문제. (like 한붓그리기 문제)

promising function 
1. i_th node -> (i+i)th node가 연결되어 있어야 함.
2. (n-1)th node -> 출발node로 돌아와야 함.
3. i_th node can not be one of zero ~ (i-1)th nodes. : 이미 방문했던 sequence안에 다시 i번째 노드가 있을 수 없음

### analysis
- BF complexity : O(n!), DP 방법도 존재함.
- backtracking : node 생성 수, running time.

### advanced design issues (학부 이후)
state-space tree
1) node  개념
2) edge 개념
3) branching factor 몇 개?

### backtracking algorithm design
- N-Queens, subset sum problem : non-optimization problem. (Y/N)
- 0/1 Knapsack problem : optimization problem. (최적화 문제)
=> compute promising function/bounding function/evaluation function
==> nonpromising if < Best
==> f = g(exact) + h(estimate)

**Maximize optimization problem** (ex. 0/1 KS)
: upper bound 계산 in each node

**Minimize optimization problem** (ex. TSP)
: lower bound 계산 in each node

**backtracking = DFS + bound function**
Q. DFS를 BFS visit으로 전환하면? 
A. branch and bound
=> is new algorithm!

Q. Backtracking vs Branch and Bound
A. Backtracking = DFS + bound function
Branch and Bound = DFS + bound function
=> 차이는 DFS vs BFS

Q1. DFS와 BFS의 장단점.
A. in practice, B&B가 backtracking보다 더 선호됨. (BFS >> DFS)
BFS : reliable(optimal을 찾아나가는 데 더 안정적임.)
장단점 정리하기..!

Q2. f = g + h < Best (bound function) 관점에서 비교하면? (0/1 Knapsack)
A. tree traverse(child visit) 순서에 따라 g value, h value의 update 차이가 발생.
- 미래 estimate인 h-value가 좋으면(정확한 예측이 가능하면), 잘 맞춘다. 
=> BFS로 진행하는 것이 좋다. 
==> start root 근처에서 pruning이 일찍 발생할 수 있다.
- backtracking은 탐색을 진행할 수록, g-value가 빨리 갱신된다.
=> g-value가 정확해지고, h-value에 대한 불확실성이 빠른 속도로 줄어든다.
key point : h-value 설계/추정/수식 유도 등의 경험을 통해 자신감이 향상되면, B&B가 우월함. 
	그렇지 않으면 backtracking 선호.

