theory of computation 과목의 주제

"P <= NP <= EXP <= Countable"
경계가 명확하지 않음.
![[Pasted image 20240620122810.png|300]]

Countable problems:
Q1. 0과 10 사이의 정수의 개수는 몇 개입니까? => finite countable
Q2. 0과 10 사이의 실수의 개수는? => infinite countable
Q3. 0과 무한대 사이의 정수는 몇 개인가? 
Q4. 0과 1 사이의 실수가 0과 10 사이의 정수 개수보다 많은가?
난이도가 굉장히 높은 문제.
computation이 가능한 문제보다 좀 더 바깥 쪽에 있음.

Q. sort 문제(P)는 knapsack 문제(NP)보다 쉬운가? 증명하시오.
A. 문제의 난이도 클래스가 달라서 디자인이 달라지게 됨. (문제의 난이도 클래스 확인 -> proper design과 analysis가 중요.) : approximation 알고리즘 디자인이 적합함.

여러 관점(교수자/교과서)에서 다양한 이론 제시와 이해
Easy problem vs intractable problem
1. easy problem: good algorithm  존재, polynomial time complexity
2. intractable problem: difficult to treat or work
	(No Polynomial-time algorithm), NP(x)

P-class definition: 
the class of decision problems that are polynomial bounded.
T(n) = polynomial function of 'n'
: problems solvable in polynomial time.

EXP-class : problems solvable in Exponential time.
	(N-queens, Knapsack, ...)

 
## Problem Classification
**Categories**
1. Problem proven to be in P-class : sort, search, CMM, SP, Dijkstra,.... => easy, efficient, fast, optimal, tractable.
2. Problem proven to be NOT in P-class : "a few" 
	: O(n^2) -x , O(n^4) -x , O(n!)과 같은 complexity가 나와야 함.
	: determine all Hamiltonian paths - O(n!) only BF
	: Non-Polynomial amount of output
	: "halting problem" :given a computer program(algorithm), does it stop/halt? YES/NO
		: P time안에 가능한가? => NOT in P-class 
		: famous because it was the FIRST problem proven to be uncomputable/undecidable.
```
		main()  // 오류 없이 종료되는지 판단할 수 없음.
		{
			while (true) {
				....
			}
		....	
		}
```

3. Problem proven "neither" to be in P "nor" to be intractable.
	: Knapsack, Graph coloring, TSP, Subset sum, ... 
	(1)도 아니고 (2)도 아님.
	심증: (1)category << (3)category 난이도
		(3) could be(1) in the future.
		: 우리의 관심은 (3)문제 범주 NP-class 문제

### NP Def (loosely speaking)
NP is the class of decision problem for which a given solution can be checked quickly (in P-time) **to see if it is true : polynomial time안에 답을 검증할 수 있다.**
<- 솔루션을 빠르게 계산하는 nice algorithm을 찾지 못 함.
<- 일단 솔루션이 주어졌다고 가정하고 출발.
1. magic algorithm으로 polynomial time안에 풀리는 Decision problem 집합
	magic algorithm -> NP에서 솔루션을 주는 건 nondeterministic algorithm/machine(polynomial time nondeterministic algorithm : step2 verification 단계가 polynomial time안에 끝나는 걸 의미하는 머신)
	1. nondeterministic Guess (step1)
		주어진 문제에 답이 있다면 unit time안에 correct solution을 guess.  (다른 고려사항, 조합을 생각할 필요 없이.) => only useful for problem classification
	2. deterministic verification (step2)
		: verify the guessed solution
	=> NP의 정의 : 
	1) ==polynomial time 안에 nondeterministic algorithm으로 풀 수 있는 문제들의 집합==
	2) Decision problem을 의미
	
2. **polynomial time 안에 check(verify) 될 수 있는 Decision problem 집합**
P 문제는 NP 문제의 subset.
같지는 않음.


**TSP** 
optimization problem과 decision problem으로 나눠 생각할 수 있음. 
optimization problem: optimal tour
decision problem : is there a TSP tour with cost < 200? -> Y/N
주어져있는 문제의 표현 방식. 예/아니오로 답할 수 있는 문제 : decision problem

**Knapsack**
optimal problem : max total profit
decision problem : is there a set(A) with profit > 100 -> Y/N

**Graph Coloring**
optimization problem : minimum number of colors
decision problem : m-colorable? - >Y/N

-> Q. TSP는 P인가 NP인가?
-> Q. sorting은 P인가 NP인가?

**Clique Problem**
complete subgraph -> Bioinformatics, SNS
clique size => size=4(blue), size=3(green)
![[Pasted image 20240620170639.png|300]]
optimization problem : find maximum clique
decision problem : determine whether a graph contains a clique of at least a given size 'k' -> Y/N


-> Q. Knapsack은 NP인가? 
A. no.
ex. 최대 500 profit을 return 하는 item 집합 A가 주어지면, 이것이 maximum인지 P-time check(Y/N)가 가능한가? (답이 가능하면 NP 문제.)
optimization problem : NP (x)
	P-time안에 답 불가.
	2^n의 조합 비교를 통해 -> real maximum, optimal 판별 가능
decision problem : NP (o)	
	polynomial verification : 
	possibly difficult to solve DPs, but easy to verify it.
	-> Knapsack의 decision problem은 polynomial time 안에 판별 가능.
	--> A = {i1, i3, i4} > 500 ? Y : N -> O(n) verify 가능


**Subset sum을 해결하는 nondeterministic algorithm 예시**
x는 nondeterministic choose function{q, r}을 쓸 수 있음
x는 q 또는 r을 assign할 수 있음. (int i = q or r;)

n=3의 subset이라면 O(2^3)인가?
그렇지 않음.
nondeterministic가 가능하다면, 3을 담는 경우와 담지 않는 경우가 동시에 계산 가능.
```
for (i=0; i<n; i++)  // 해당 방법으론 실제로 불가능.
{
	seleted = nondeterministic.choose(T, F);
	if (selected) sum += s[i];
}  
```
3회 만에 계산 해결.


### NP-Complete
CS에서 중요한 문제들의 대부분은 NP문제임.
많은 문제들이 polynomial time으로 입증되지 못 함.
그 문제들 중 하나가 polynomial time안에 풀리면 모두 polynomial time 안에 풀리지 않을까?
=> NP 중에 제일 대표적, 어려운, core, 완전한 문제를 찾아보자.

(def1) 어떤 문제 B가 아래 두 조건을 만족하면 NP-complete이다.
1) B는 NP이다.
2) 모든 NP 문제인 A가 있으면, A가 B로 바뀔 수 있어야 한다. (transform, reduce)

(def2) 어떤 문제 C가 아래 두 조건을 만족하면 NP-complete이다.
1) C는 NP이다.
2) NP-complete인 B를 가져와서 B를 C로 transform

Cook's Theorem 
CNF(SAT) 문제가 P-class 문제라면, P\==NP
CNF 문제는 NP-complete이라는 걸 증명. => 최초의 CP-complete 문제.

CNF-Satisfiability (Boolean SAT) Problem == NP 문제
CNF : Conjunctive Normal Form
ex. (x1 or x2) and (x2 or not x3) and not x2 = F (bool expression)
CNF decision problem version에선 F를 true로 만들기 위한 x1, x2, x3에 대한 진리표 할당이 이루어질 수 있는지 물어봄.  => YES if x1=T, x2=F, x3=F.
Q. bool variable 100만개를 참으로 만드는 조합이 있는가? CNF. 해결해라.
A. BF, Greedy, D&C, B&B => design/analysis


### NP-complete and Transformation
주어진 어려운 문제를 NP-complete으로 증명할 수 있다.

SAT 문제가 나의 문제로 바뀌어야 하고, NP-complete 중 하나가 해결되면, 다른 NP-complete도 변환해서 해결. 

**transformation algorithm/technique**
A를 풀고자 한다. A를 해결할 순 없고, B를 푸는 algorithm을 알고 있음.
A를 풀기 위해 
1) transform(reduce) x -> y
2) apply algorithm for B.
=> A의 instance를 B의 instance로 바꿔서 A가 yes면, B도 yes, 반대도 성립되게 하는 알고리즘

definition : A부터 B인 polynomial time 알고리즘이 있으면, A가 B로 polynomial time reducible(transformable)하다.
Theorem : Decision problem인 B가 P-class이고, A가 polynomial time 안에 B로 바뀔 수 있다면, A도 P-class 안에 있다.
- SAT는 decision programming이기 때문에  transform 가능한 문제 역시 decision programming 형태를 가짐.
	=> SAT(DP ver)이 나의 문제로 변환되려면, 나의 문제도 DP ver여야 함.

예. Hamiltonian circuit decision problem
증명 : NP-complete
1) Hamiltonian circuit decision problem은 NP이다.
2) SAT decision problem이 polynomial time 안에 Hamiltonian circuit decision problem으로 변형 가능해야 한다. (이미 증명되어 있음.)

Quiz. TSP.DP가 NP-complete인가?
A. TSP.DP가 NP임을 보여주고, NP-complete(HC.DP) 문제가 polynomial time 안에 TSP.DP으로 바뀐다는 걸 보여줘야 함.
![[Pasted image 20240620195559.png|400]]
![[Pasted image 20240620195817.png|500]]


Message:
subset sum이 NP-C 증명되었다면 0/1 Knapsack도 NP-C 증명.
=> NP-C pool이 있다면 내가 원하는 어려운 문제(기말시험, 필드 응용 문제 등...)을 polynomial time 안에 바꿔보기. 문제의 난이도를 알 수 있음. 

### NP-hard problem
Q. TSP는 NP 문제인가? NP-complete인가? -> No
Q. TSP.DP는 NP 문제인가? NP-complete인가? -> Yes

Sunset, Hamiltonian circuit, N-Queens : 본질적으로 decision problem

Knapsack, TSP : 본질적 optimization 최적화 문제.
=> 문제들에 대해 질문할 때 decision과 optimization을 나눈 것임. 그냥 찾아라 하면 optimization을 말하는 것임.
NP-compelte는 decision 버전으로 국한시킨 것.

Q. 최적화 문제/버전/표현으로 제시된 문제는 어떤 분류?
A. NP-Hard category
**(def) A가 NP-Hard는 한 가지 조건이 만족하면 된다 .NP-complete인 B가 polynomial time에 A로 변형이 성공하면 됨. (A가 NP에 속한다는 말이 없음. A가 NP인지 말하기 어려운 문제.)**
A가 NP-complete인 건, A가 NP이고, transformation이 동작하는 문제임.

TSP(optimization problem)의 verification이 p-time 안에 check(verify) 가능한가?
: 주어진 TSP에 대한 solution이 빠르게 검증 가능한가?

given solution 100개 도시를 1시간 내에 다 돌고 돌아오는 게 가능한가? -> Y/N p-time 안에 가능. O(n)

given solution인 가장 적은 path가 주어진 것이라는 게 검증이 되나?
-> N : O(n!) verification : NP라고 할 수 없음.

 Knapsack(optimization problem)의 verification이 p-time 안에 check(verify) 가능한가? ==> NP-hard
 -> given soultion에 대한 O(2^n)에 대한 verification이 필요함. 

