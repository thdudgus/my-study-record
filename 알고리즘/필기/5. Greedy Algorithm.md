Grans data items in sequence, each time with BEST choice, withput thinking future
BEST : local optimal choice (o), global optimal(x)

왜 greedy algorithm이 CS에서 중요한가?

example : MST : Minimum Spanning Tree
<br>

# Greedy algorithms design
while문과 같은 반복이 들어감
	step1. selection (local optimal choice, ranking이 이루어져야 함.)
	step2. feasibility (문제의 조건을 위배할 가능성이 있기 때문에, 제약 조건을 만족하는지 확인해야 함. - optional)
	step3. solution check (termination)

Ex. MST

```
F = empty set
greedy_MST (input: graph G=(V, E))
while NOT solved yet {
	select an edge e (local optimal choice)  -> ranking(scoring) function이 필요함.
	if e create NO cycle then add e to F
	if T = (V, T) is a spanning tree
}
---> output : MST T = (V, F) F is subset of E.
```
-------> 어떻게 e를 선택하나?  Prim's alg, Kruskal's alg.
<br>
![[Pasted image 20240425064632.png]]

<br>

# Prim's algoritm
Prim's algoritm : **node(vertex) based approach(ranking)**

```
F = empty set
Y = {v1}
while NOT solved yet{

	select v in V-Y nearest to Y; 
	// selection  (node 집합 V에서 vertex Y와 가장 가까운, Y 제외 vertex 중에 v 선택) 
	
	feasibility test (cycle?)  
	// 불필요 : 이미 내가 연결된 노드에서 짧은 노드를 가져오기 때문에 cycle이 없음. 
	// 연결이 안 되어있는 vertex 집합을 연결시키는 것이기 때문에 cycle이 생길 수 없음.
	// node based approach
	
	ADD v to Y
	if V == Y, then stop/exit  // (Y가 점점 커지게 되다가 V와 같아지면 멈춤)
}

```
![[Pasted image 20240425064715.png]]

<br>

# Prim's algoritm Analysis
1. time complexity T(n)는 local optimal choice와 feasibility 부분이 좌우함.
	T(vertex의 수=|v| = n) = T(n) ~= O(n^2)
2. proof가 필요함. (반드시 proof 되어야 하는 건 아님)
![[Pasted image 20240425064757.png]]

<br>

# Proof of greedy algorithm.

Prim's Theorem : Prim's alg produces MST
proof : .............. by induction, proof by contradiction (greedy approach)

(Base) F = empty is promising (MST)
(H) Assume F is promising (MST T = (Y, F))
(Induction) F+next edge ( 그 다음 생성되는 MST)가 MST라는 걸 보이기.

proof on induction is required --> Lemmma.
(테크닉 : 모순에 의한 증명)
contradiction : NOT - F+next edge ( 그 다음 생성되는 MST)가 MST임을 이용해 증명.

contradiction : 
T = (Y, F) ----> prim algo가 생성하는 next tree T (prim) = (Y+v, F+e). 이것이 MST가 아니다
즉, 다른 optimal MST가 존재한다고 가정. 
: T(opt) = (Y+v', F+e')라는 MST 존재.

위 문장을 적용하면
T(opt)이 T(primP보다 총 weight합이 작다.
	-> 그러나 weight(T(opt)) > weight(T(prim)) ..... e'>e
		prim algo로 연결된 엣지들 중 가장 작은 것만 골랐고, 가중치의 합이 가장 작은 T를 찾았는데 다른 T'가 더 가중치가 작을 수 없음.  ==> conflict 발생.

<br>

# Kruskal algorithm
edge 집합 E를 정렬하여 그걸 토대로 MST 생성.

```
Kruskal_MST(input G)

sort edge set E
while NOT solved yet{
	select next edge e : from sorted list
	if cycle check? // edge 기반 approach이기 때문에 cycle이 생길 수 있음. 
		cycle이 생기면 버리고, 안 생기면 add to e
		(Q. cycle 체크는 어떻게 하나?
			set of tree : forest data structure : find and union operation 이용.
				find (트리의 root를 찾는 연산)
				union (두개의 root를 연결하는 연산)
			두 트리의 루트가 같은지 체크
				yes : cycle o
				no : cycle x, add e -> 반복)
	if stop condition : yes->stop, no->repeat
```

1. F <- empty
2. create 'n' disjoint sets : {v1}, {v2}, ..., {vn}로 초기화
3. edge set E 정렬
4. while NOT solved yet{
	select next edge e : from sorted list
	if (cycle check) 'e' connects two subsets, 
		then, 합친 후, e를 F에 더한다.
	if stop conditin TEST

**CYCLE CHECK** : find-uniun operation
e = next edge: {i, j}
p = find(i)  // vertex i 의 root node
q = find(j)  // vertex j 의 root node
if p != q ---> connect and merge
add e to F

find(j) != find(k)

![[Pasted image 20240425064816.png]]

<br>

# Kruskal algorithm Analysis  
T(n) =? |V|=n, |E| = m
1. 초기화 : theta(n)
2. sort : 정렬 알고리즘에 따라 다름. O(mlogm)이라 가정.
3. while loop : O(m * cycle-check인 alpha(n,m))   ----> O(mlign)
4. 남은 연산들

-----> T(n, m)=O(mlogm)
-----------> edge 개수 : <= n(n-1)/2
<br>

# Prim's alog vs Kreuskal algo
: 둘다 증명 완료돼있음
: 시간복잡도 : O(n^2) vs O(mlogm)
----> 후자가 더 빠름.
