### divide and conquer general design
문제를 두개 이상의 작은 subproblem으로 나누고, 그 작은 문제들의 솔루션을 얻을 수 있을 때까지 나눈다. 
문제들을 쪼갠 후 해결(conquer)

**divide and conquer는 top-down approach이다.**

**Step**
1. Divide into 2 or more smaller problems
2. Conquer (solve each instance)
3. Combine the subsolutions (optional)

How to solve the step2 ?
- recursively : divide and conquer
	장점 : concise, natural, clear, 기계적 해법.
- interatively, sequentially (if the subproblem is small)
	장점 : faster, save memory space(system stack -> recursion depth, stack depth : log(n)+1 )
<br>
---
# Binary search
> 정렬되어 있는 리스트에서 탐색 범위를 절반 씩 좁혀가며 데이터를 탐색하는 방법.

이진 탐색은 가장 간단한 divide and conquer 알고리즘의 한 종류이다.   
문제가 작은 문제로 나누어지고, 해결되기 때문. (combine 단계  없음.)

이진 탐색의 recursive version은 tail-recursion이기 때문에 iterative version을 쉽게 만들 수 있다.
recursive call로 생긴 스택을 삭제함으로써 상당한 양의 메모리를 절약할 수 있다.

iterative 알고리즘은 recursive보다 빠르게 수행할 수 있다.

### Divide-and-conquer approach (이진탐색에서)

**재귀적 방법** -> top-down approach, natural design
- **Divide** : A[1..n] into two parts A[1..mid-1] and A[mid+1..n]
- **Conquer**: if A[mid]=x, return mid            
			if A[mid]<x, return A[mid+1..n] for next iteration // 찾으려는 값보다 mid가 작으면 mid보다 큰 쪽에 찾으려는 값이 있음.            
			if A[mid]>x, return A[1..mid-1] for next iteration // 찾으려는 값보다 mid가 크면 mid보다 작은 쪽에 찾으려는 값이 있음.            
- **Combine**: just return the result (combine 단계 필요 없음.)

recursion depth, stack depth : log(n)+1

### Divide and Conquer의 Time Complexity (이진탐색에서)
Time Complexity = 기본 연산의 수
T(n) = divide + conquer + combine
= ?+ ? + ?
= ? + ? + 0 
	combine은 없음.
= 1 + T(n/2) +0
	step1에서 한 번 divide되고 그 다음부턴step2에서 divide가 되는데 알 수 없음
	왼쪽이나 오른쪽이 해결되고 combine이 되지 않음.
= 1 + 1+ T(n/4)
= 1 + 1+ 1+ T(n/8)
...
= k + T(n/(2^k))  (n=2^k라면, 양변에 밑이 2인 log를 씌우면 k=logn)
= logn + T(1)
= logn + 1 <= **O(logn)**
<br>

# Quick Sort 

> 하나의 리스트를 피벗(pivot)을 기준으로 두 개의 비균등한 크기로 분할하고 분할 된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법.
> ![[Pasted image 20240425022339.png|370]]
> ![[Pasted image 20240425022352.png|400]]
> ![[Pasted image 20240425022150.png|500]]

### Divide-and-conquer approach 
divide and conquer에서 combining step 없이 sorting이 가능한가?

1. 왼쪽과 오른쪽 부분을 나누기 (divide)
   왼쪽에 divide된 element들은 오른쪽에 divide된 element보다 작아야 한다는 관계성이 있어야 함. 
	-> divide의 중요성이 부각됨.
	-> left < pivot < right, (pivot은 기준, 리스트가 정렬되어있지 않기 때문에 middle은 안 됨. 그냥 random값)
2. 각각의 부분 정렬 (conquer)
```
D&C_Sort (low, high :array index)
{
if (high >low) // stopping condition, termination condition
	{
		Divide(low, high, pivoit_index);
		D&C_Sort(low, pivoit_index-1);  // left
		D&C_Sort(pivoit_index+1, high);  // right
	}
}
```

pivot 값을 중심으로 왼쪽엔 작은 값, 오른쪽엔 큰값이 나오도록.
pivot보다 작은 값을 저장할 새로운 index j 필요.
index i를 하나씩 증가시키면서 비교. 

index i에서 pivot보다 작은 값이 있다면, 새로운 index j를 i로 하고 두 값의 위치를 swap.
i를 증가시키며 계속 pivot과 비교하고 pivot보다 크다면 그대로 두고 작다면 i와 j를 swap.
마지막까지 비교 후 j와 pivot의 위치를 swap

-> 이 과정을 마치면 pivot을 중심으로 왼쪽엔 pivot보다 작은 값, 오른쪽엔 pivot보다 큰 값으로 나누어지게 됨.

<br>

### Divide and Conquer의 Time Complexity (퀵 소트에서)
T(n) = divide + conquer + combine
= ?+ ? + ?
= n-1 + (T(n/2) + T(n/2)) + 0 = 
= pivot을 제외한 수들을 모두 검사하기 때문 + 왼쪽과 오른쪽 정렬+ combine 필요x 
	but, 왼쪽과 오른쪽의 element의 개수가 n/2개로 등분되지 않을 가능성이 존재하기 때문에 완벽한 식이 아님. 다시 말해 운이 좋게 pivot이 중간값이라면 의미 있는 식. 
	-> best time complexity
= (n-1) + 2T(n/2) 
= 2T(n/2) + n 
= 4T(n/4) +2n
= ... 
<= (2^k)\*T(n/(2^k)) + kn,  (n=2^k라면, 양변에 밑이 2인 log를 씌우면 k=logn)
= nT(n/n) + nlogn 
= nT(1) + nlogn
- n\*0 + nlogn = nlogn = **O(nlogn), 가장 시간이 많이 걸리는 Upper bound**

<br>

# Recurrences
design approach를 잘 선택하는 것이 목표. 
## recurrence equations
1. 수의 sequence를 describe
 - early terms(numbers)를 분명하게(빨리) specify
 - later terms는 미리 나온 것(predecessors)에 의해 계산된다(표현된다).
	ex) T(1) = 1, T(n) = T(n-1) + 1

2. 큰 문제는 작은 문제 unit으로 줄어든다. 
	쉬운 cases(terms)로 도달할 때까지.(progressively)

3.  recursive algorithms의 performance를 분석하기에 Useful and powerful 
	-> Time complexity analysis에 도움이 됨.


**divide and conquer가 recurrence와 동일한가? -> 아님.**
recurrenc로 표현된 문제를 모두 divde and conquer로 표현할 수 있는가 
-> recurrence로 표현되었는데 divide and conquer로 풀면 비효율적인 것들이 존재.
<br>

## Two big classes of recurrence in CS
1. **linear recuurence**
	later terms = linear combination of early terms. : linear algebra
		e.g. fibonacci recurrence ( f(n) is a linear combination. )
2. **divde and conquer reccurence**
	e.g. merge sort recurrence
		T(1) = 0
		T(n) = 2T(n/2) + n - 1 : **not a linear combination** of proceding terms.
			-> divide and conquer recurrence. 
		T(n) is a function of T(n/2)

**time complexity의 관점에서 보면,**
fibonacci recurrence(linear recurrence)의 time complexity는 
T(n) = T(n-1) + T(n-2) n-> O(2^n) : not tight bound, ~ O(1.6189^n/sqrt(5)) : tight upper bound 
-> exponential time complexity를 가짐. -> 큰 비용이 듦.

mergesort recurrence (divide and conquer)의 time complexity는 
T(n) = 2T(n/2) + n - 1 -> T(n) ~ O(nlogn)

**-->linear recurrence는 divide and conquer recurrence에 비해 큰 비용이 듦.**
<br>

# Observations -> Guidelines (in Reucurssion)
1. recursive call마다의 extra step을 줄이는 것보다 알고리즘의 속도(효율성)를 위해 **지속적으로 문제를 작게 생성하는 것이 중요**함. 
	ex) fibonachi와 mergesort
2. 더 일반적으로, linear recurrence(subproblem이 큼)는 전형적으로 exponentail solution을 가짐. (매우 비효율적). 
	반면 divide and conquer(subproblem이 작음)는 주로 bounded by a polynomal time comlplexity를 가짐.
3. 만약 subprobleme들이 원래 문제의 사이즈의 분수라면, solution이 전형적으로 polynomial로 bounded. -> divide and conquer design is good.
4. even worse, fibonachi recurrence는 작은 subproblem들이 중첩되어 있음. -
	같은 terms로 부터 반복되는 계산 발생. -> 매우 비효율적.
		어떻게 fibonachi를 다룰 수 있을까?
		we know that the recurrence can be implemented recursively as well as iteratively. 
		-> iteration 이용 : f0과 f1이 있다는 가정 하에 f2, f3, f4, f5를 계산.
		-> 새로운 디자인이 소개될 수 있음. = dynamic programming

### linear recurrence
1. General Math. definitions and general solutions.
2. Two general solving techiques
	1) guess-and-verify
	2)  plug-and-chug
		--> every reccurence에 적용 가능.
3. Homogeneous(inhomo.) linear recurrence
	f(n) = a1\*f(n-1) + a2\*(fn-2) + ... ad\*f(n-d) + g(n)
4. Ex : Fibonachi reccurence -> solution.
	 Ex : Towers of Hanoi. f(n) = 2f(n-1)+1

<br>

# analysis in advanced / real-life techniques
e.g. cahtGPT, transformer

현재 학부생 알고리즘 평가 척도 Performance measures
- 이론적 Big-O, optimality proof, runtime speed
- 강의 후반부 : 추정값 -> approximate solution quality 보장

언어처리 인공지능 LLM (Large-scale Language Model)
Chat GPT = 강화학습 + 지도학습 + 언어모델 + ... = Chat Generative Pre-trained Transformer. 
Transformer algorithm (by google 2017) : attention module-based.

알고리즘의 평가척도는 다양, 도메인에 따라 다름. 

<br>

