왜 11의 용어들을 배웠나?
1) approximation alogorithm을 쓰는 근거.
2) 3-2의 전공과목을 배우는데, NP-hard 용어를 많이 보게 될 것. 
	=> approximation O, optimal X.

## approximation algorithm의 특성
1. 근사(치) 계산 : 알고리즘 개발 쉽다. easy, suboptimal
2. 근사 -> optimal solution에 얼마나 가까운지 제시해야 함.
	1. 수학적 방법 : bound theorem
	2. 실험적(empirical ) 방법 : 정확도, relevancy 제시해야 함.
3. 얼마나 빠른지(효율적인지)에 대한 제시가 필요.
	1. 수학적 : time complexity = polynomial time
	2. 실험적 : execution time, running time (in sec)

####  bound theorem
boundness 개념 : 우리는 optimal을 계산하기 어렵다.  (polynomial time 내에)
h < h\*
optimal solution과의 관계성을 수학적으로 표현. 
ex. approximate solution < optimal\*2
approximate solution < optimal\*10
범위가 tight할 수록 대체로 좋음.
better if better bound.

### 개발 접근법
**Heuristic greedy-based(대부분)**
classifical greedy alg vs approximation greedy
전반적인 접근 비슷하지만, 전자는 실제 optimal이 될 수 있음. 후자는 정답을 못 구한다는 걸 알고 있기 때문에 근사값을 취함.

## Approximation Algorithm for TSP (design/analysis)
idea : MST를 이용하여 TSP를 해결.
- MST : short edge 연결
- MST : no cycle
- MST로 연결된 구조 -> round-trip route/path 구성 용이
- preorder traverse

design
1. determine a MST (using Prim's alg) : ranking
2. Create a path around the MST (using preorder visit)

analysis
1. time complexity : polynomial time O(n^2)
2. boundness (theorem, proof)
	: approximate solution < optimal solution (관계성)

boundness : approximate path(p) < 2 \* optimal path(p\*)

cost(MST.path) < cost(p\*)
![[Pasted image 20240620212957.png|400]]
cost(Full walk on MST) = 2 \* cost(MST.path)
==> cost(Full walk on MST) < 2 \* cost(p\*)
![[Pasted image 20240620213123.png|150]]
cost(p, 녹색) < cost(Full walk on MST) (by triangular inequality)
==> cost(p) < 2 \* cost(p\*) 증명!


## Approximation Algorithm for Bin Packing (design/analysis)
n개의 item들이 있고 각 사이즈는 s1, s2, ..., sn (0 < si <= 1)
(unit cap bins=1.0)bin의 최소 수를 찾아라. 

응용 : 이삿짐, 여행가방 packing issue
- 인테리어 레이아웃
- 게임/서버 load balance issue

Q. bin packing 문제를 해결하시오.
A. 문제의 problem-level classification => 난이도 파악!

ex. n = 8, item size = 0.85, 0.1, 0.5, 0.2, 0.4, 0.4, 0.3, 0.2, ... 
1. approximation design : item을 nonincreasing order로 정렬
	![[Pasted image 20240620214544.png|400]]
optimal은 3개에 담을 수 있음.
![[Pasted image 20240620214617.png|400]]


**analysis**
1. time complexity: (polynomial time) T(n) = O(nlogn)
2. bound theorem (quality)
=> approximate bin < optimal bin * bin (theorem)
==> NFF(Nonincreasing First-Fit)로 배치되는 extra bin의 item들의 size <= 1/3 (lemma)
![[Pasted image 20240620214944.png|400]]

