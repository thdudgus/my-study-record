### 알고리즘의 Time complexity analysis
input size의 각각의 값에 따라 기본 연산이 끝나는 데에 얼마나 시간이 걸리는지 결정하는 것.


### Complexity (복잡도)
- T(n) : every-case time complexity   
	크기가 n인 instance에 대해 알고리즘이 기본 연산을 수행하는 횟수로 정의됨.   
- W(n) : worst-case time complexity   
- A(n) : average-case time complexity   
- B(n) : best-case time complexity   


### Order
시간 복잡도가 n, 100n인 알고리즘은 입력 크기 n에서 선형이므로 선형시간 알고리즘(linear-time algorithm)이라고 한다.
시간복잡도가 n^2, 0.01^2과 같은 복잡도는 n에서 2차로, quadratic-time(2차 시간) 알고리즘이다. 
모든 선형 시간 알고리즘은 quadratic-time 알고리즘 보다 효율적이다.


5n^2, 5n^2와 같은 function은 pure quadratic functions
0.1^2 + n +100과 같은 fuction은 complete quadratic function

어떤 알고리즘의 시간 복잡도가 θ(n^2)라면 quadratic-time algorithm이다.


**시간 복잡도를 정확히 알기 어렵다면, 그 order를 가려내는 걸로 만족해야 한다.**   
<br>

## Big-O natation
aBig-O는 stmtotic behavior을 describe한다. (점근표기)
complexity f(n) = O(g(n))은 "f(n)은 g(n)의 차수"라고 읽는다.
이 complexity f(n)은 n >= N(n_0)인 모든 자연수 n을 입력으로 하는 알고리즘이 수행될 때, 
그 수행시간이 fn <= k\*g(n)이 되는 양의 정수 k와 N이 존재하면 성립한다.

알고리즘이 n개의 입력으로 수행될 때, 그 수행시간이 |g(n)|에 양의 정수 k를 곱한 것보다 같거나 작은지 확인하면 된다.
![[Pasted image 20240425002204.png]]   
**어떤 알고리즘의 시간 효율성을 보여주는 그래프 f(n).**
이때 N(=n_0)보다 충분히 큰 입력값 n을 넣었을 때, 알고리즘 f(n)의 running time이 최악인 경우에도 점근 상향선인 k\*g(n)을 넘을 수 없다. 이때를 O(g(n))이라고 나타낸 것이다.

**g(n)에 어떤 양수 k를 곱했을 때 특정 양수 N에서 f(n) 보다 크다면 그 g(n)이 Big-O time complexity 가 된다.**

빅오(Big-O) : upper bound, 최악의 경우.
빅오메가(big-Ω) : lower bound, 최선의 경우.
빅세타(big-θ) 