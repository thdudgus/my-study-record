single source : 출발점이 정해져 있고 도착점까지 가장 짧은 길

problem -> model -> solution algorithm
1. problem : find a shortest path from A to B
2. model : a weigh graph G=(V, E)
	-> function f : E(sequence of edges) -> R
	-> find the minimum R(total const = min weight)
	-> Single Source Shortest Path (SSSP) : G given, S(starting vertex) 주어졌다고 할 때, 
	-> find shortest paths from S to v in V : delta(S, v)
3. solution Algorithm:
	-> Dijkstra (non-negative edge weight)
	-> Bellman-ford (negative edges)

Dijkstra와 Bellman-Ford는 single source shortest path를 위함.
1. idea : Dijkstra - S로부터 가장 가까운 v를 찾고 relax ....
	   Bellman : simple relax ALL edges for |V|-1 time
			-> 인접한 matrix가 지속적으로 업데이트
2. 구현 난이도 : Bellman (easy) >> Dijkstra
3. time complexity : Bellman O(V\*E) = O(n^3) < Dijkstra O(N^2= V^2)
				|E|의 최대 개수는 n(n-1)/2
4. negative weight cycle : Bellman만 가능.
5. ☆key poiny (design 관점)
	-> Dijkstra : greedy design
	-> Bellman-Ford : dynamiv programming design
		subproblem : 임의의 노드 v -> target 노드 v로 가는 short path, 
		update edge 1개, 2개, 3개....  계속 relax하면서 shortest path의 길이를 확장해나가는 것.
<br>

![[Pasted image 20240425063206.png]]
<br>
# Dijkstra
가장 대표적인 greedy problem

Greedy algoritmms은 optimal structure을 만족하고 local optimal이 global optimal로 간다면 greedy(fast)가 DP보다 낫다. (많진 않음)

**Dijkstra for Single-Source(start) Shortest Path**
1. relax function/conept의 관점에서
2. MST(Prim's)의 관점에서
  
**Dijkstra는 Prim's algorithm과 비슷하다.**
while NOT solved yet{
	select v in V-Y nearest to v1(source/start) 
		useing only Y as intermdiates(relax)
}

idea : 반복적으로 V-S(아직 최단 경로 결정 x인 나머지) 안에 있는 minimum u를 선택하고
u를 S(최단 경로가 결정된 집합)에 더한다.
V(vertex 집합)

negative weight가 없는 edge Single Source Shortest Path 문제에 많이 활용된다.
시작 노드 s로부터 SSSP를 찾는다.

![[Pasted image 20240425061239.png]]
![[Pasted image 20240425061336.png]]
**EXAMPLE (relax)**
![[Pasted image 20240425060046.png|500]]
min(각각의 v에 대해서 현재 v자체가 가지는 distance값, 시작점에서 경유지까지의 distance+경유지와 v의 distance)

![[Pasted image 20240425061417.png]]
<br>
# Bellman-Ford
![[Pasted image 20240425064456.png]] <br>

# Floyd - warshall algorithm (dynamic programming)
### All Pairs Shortest Path (APSP) problem

problem : 주어진 어떤 pair의 vertex(u, v), find a shortest path  from u to v.
model : on graph
solution algo : 디자인 -> 분석 -> best algorithm?
1) brute-force, enumneration : 그래프 상에 주어진 모든 출발점과 모든 도착점 간의 가장 짧은 길을 찾는 것 (모든 페어의), 모든 문제를 enumeration, 모든 경로 나열과 weight 계산 : O(n!)
2) divide and conquer : 모든 페어들 간의 짧은 길을 찾겠다. 나눈 구간 간의 간섭이나 중복이 있을 수 있음. 
3) dynamic programming : O(n^3)
	-> step 0 : example (easy small subproblems)
	-> step 1 : recurrence equation.

	what is the easiest (sub)problem?
		-> a direct path from u to v
		-> save 2D matrix (array)

	((잘못된 방법))
	u, v를 제외하고 나머지 것엔 다 경유를 해야 함. D0 -> D1 -> .... -> D(n-2)
	모든 조합 u, v의 페어에 대해 n-2의 노드를 경유하는 매트릭스가 만들어져 있을 것.
	D[i, j]는 D[u, v]가 shortest path. i to j

	D0[i, j]는 이미 계산되어 있음. (input 그래프 정보로 주어져있음), i에서 j로 가는 direct path.
	D1[i, j]는 i에서 j로 가기까지 노드 1개 경유. 이미 계산되어 있는 그 전 매트릭스 (D0)에서 나온 값들로 min 계산.
	D2
	D3
	....,=> 너무 많은 enumeration -> dynamic programming이 아님.


### ((매트릭스의 정보를 바꾼 새로운 방법))

행렬을 계속 만들어 나가며 정보를 업데이트 하는 건 맞음.
	D1[i, j] = i에서 j까지 가는 데, 직접 가거나 1번 도시를 경유할 수 있는 방법 중 minimum
	D2[i, j] = i에서 j까지 가는 데, 직접 가거나 1번 도시를 경유하거나 2번 도시를 경유할 수 있는 방법 중 minimum
	D1[5, 4] = min(A=D0[5, 4], B=D0[5,1]+D0[1, 4]) = min(A, B) = min(inf, +1) = 4
	.....,  D1의 값이 모두 채워지게 됨.

A는 2번 도시를 거치지 않고 가는 길. B는 2번 도시를 거쳐 가는 길.
	D2[5, 4] = min(A=D1[5, 4], B=D1[5,2]+D1[2, 4]) = min(A, B) = min(4, 4+2) = 4
	.....,

A는 3번 도시를 거치지 않고 가는 길. B는 3번 도시를 거쳐 가는 길.
	D3[5, 4] = min(A=D2[5, 4], B=D2[5,3]+D2[3, 4]) = min(A, B)
	......,
	
k = 경유지
	Dk[i, j] = min(k를 거치지 않는 경우, k를 경유하는 경우)
		= min(D_(k-1)[i, j], Dk[i, k]+D[k, j])

<br>

# Floyd Recurrence

```
Dk[i, j] = = min(D_(k-1)[i, j], Dk[i, k]+D[k, j])

procedure Floyd (input : graph D)
	for loop k=1 ->
		for loop i...
			for loop j...
				Dk[i, j] = = min(D_(k-1)[i, j], Dk[i, k]+D[k, j])
```
Q. 우리는 D0, D1, D2,... 대신에 2차원 배열 하나로 전체 계산을 커버할 수 있나? (메모리 최적화 가능)
A. 가능. 교재 참고.
CMM에서 최적의 곱은 

Time complexity = O(n^3), n= |V|
for loop이 3개인데 각각 다 n 만큼 반복.

Q, shortest path를 계산한 게 아니라 shortest distance를 계산한 것.
	가장 짧은 i에서 j까지의 길은 어떻게 출력할 수 있나?
A. Dk[i, j] = = min(D_(k-1)[i, j], Dk[i, k]+D[k, j])에서 후자(k)를 선택한다면(if문), 이는 지나온 길이기 때문에 따로 저장해두고 출력한다.
	save the 'k' vertex 저장. 교재 참고.

<br>

# Dynamic programming의 property
pinciple of opimality == optimal substructure

all subsolution of an optimal solution are optimal.
opimal subsolution can build up a global(final) optimal solution.

만약 어떤 문제 A가 pinciple of opimality == optimal substructure를 만족하면 DP가 best design(optimal result)을 제공한다. DP가 optimal을 보증.
(DP가 문제의 답이 정답이긴 하지만, 가장 효율적인 디자인을 말하는 건 아님. )

Floyd algorithm은 항상 optimal


ex. longest simple path problem. (가장 긴 사이클 없는 path는?)
	optimal substrure을 만족하지 않음. 
	1-3-2-4이 optimal이라면 1-3도 optimal이어야 하는데, 더 긴 1-2-3이 있음. principle of optimality를 만족하지 않음. 