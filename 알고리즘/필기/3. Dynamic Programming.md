## Binominal design
(n, k) = (n-1, k-1) + (n-1, k),  if 0<k\<n 
경우의 수 n C k
= 1 (if n\==k or k\==0)

B[n, k] = B[n-1, k-1] + B[n-1, k], if 0<k\<n 
 B[n, k] = 1 (]if n\==k or k\==0)

Question : solve B[5, 3] = (4, 2) + (4, 3) 
```
divide and conquer binomial(n, k)
{
	if (n==k or k==0) return 1;
	else
		step1 -> 이미 divide되어 있어서 필요 없음.
		step2 -> left = divide and conquer binomial(n-1. k-1); // left
				right = divide and conquer binomial(n-1. k) // right
		step3 -> return left+right
}
```
=> B[5, 3] = B[4, 2] + B[4,3]
	B[4,2] = B[3,1] _ B[3, 2]
	...
=> linear recurrence

n과 k가 같이 있음 : multidimensional recurrence
**observe 'subproblem overlapping'**
fibonacci recurrence
-> divide and conquer가 아님 => 비효율적 => 새로운 approach 필요

Brute-Force, Full/Exhaustive Enmeration
<br>

# Dynamic Programming Design
어떤 문제가 subproblm으로 나누어져 문제를 풀 수 있어 보이고 recurrence가 있어 divide and conquer처럼 보이지만 divide and conquer recurrence가 아님.
-> subproblem overlap이 생겨 비효율적 
-> time complexity가 지수적으로 커짐 
=> dynamic programming을 활용할 수 있음. **(note : principle of optimality, optimal substructure)**

step 1 (이 단계가 중요!)
	- 주어진 문제로부터 recursive property를 establish
	- 주어진 문제로부터 recurrence equation을 identify(find out, derive)
	- 큰 문제를 작은 문제들의 답을 활용하여 계산할 수 있음. 
step 2
	- bottom-up fashion programming으로 해결
		c.f ) divide and conquer : top-down fashion (recursion) programming
	- 작은 문제들을 먼저 해결
	- 풀려진 작은 문제들을 저장 in arrays(look-up tables, dict,...)
	- 나중에 다시 활용

Design = steps + 기본적 골격 + example
	= 디테일한 알고리즘 설계를 원하지 않음

step 나열이나 슈도 코드도 관계 없음.

**다이나믹 프로그래밍 binomial (bottom-up 방식)**
DP_B (n, k) : iterative (for, while)
n쪽의 수를 나타내는 게 i, k쪽의 수를 나타내는 게 j

### 예시 : fibonacci(5)
step 1 : fib(n) = fib(n-1) + fib(n-2)
step 2 : f(0), f(1), f(2), f(3), f(4) --> f(5) = f(4) + f(3) , for iterative, 중복된 계산은 이루어지지 않음

### 예시 : Binominal B[5, 3]
Question : solve B[5, 3]
B[2, 1] = B[1, 0] + B[1, 1] = 1+1=2
B[3, 1] = B[2, 0] + B[2, 1] = 1+2=3
B[3, 2] = B[2, 1] + B[2, 2,] = 2+2=3 
=> local neighbor 계산 활용.
**neighbor clever enumeration은 brute-force enumueraion와 다르다!**
**DP == Save and Reuse.**
<br>
# Dynamic Programming Analysis
**Time complexity는** 
**cell computations의 횟수** = subproblems \*(단위 계산 시간)time/subproblem의 횟수
<br>

# Binomial계수 Design in Dynamic Programming 

B[n, k] = B[n-1, k-1] + B[n-1, k],    if 0<k\<n 
 B[n, k] = 1 (if n\==k or k\==0)
 
=> local neighbor 계산 활용.
**neighbor clever enumeration는 brute-force enumueraion와 다르다!**
DP == **Save and Reuse.**
**이미 계산된 값을 저장하고 그걸 재활용하기 때문에 시간 복잡도를 줄일 수 있다!**

**Design = steps + 기본적 골격 + example**
	**= 디테일한 알고리즘 설계를 원하지 않음**

step 나열이나 슈도 코드도 관계 없음.
DP_B (n, k) : iterative (for, while)
 n쪽의 수를 나타내는 게 i, k쪽의 수를 나타내는 게 j
 ```
 for i=0 -> n
	for j=0 -> min(i, k) 
		if(j==0 or j==i) 
			B[i, j] = 1
		else
			B[i, j] = B[i-1, j-1] + B[i-1, j]
return B[n, k]
```

![[Pasted image 20240425032744.png|450]]
<br>
<br>

# Analysis in Binominal DP
Time complexity : T(n, k) = O(?)

divide conquer의 time complexity의 경우 : divide, conquer, combine의 step의 합.

dynamic basic operation의 time complexity의 경우
	: **array의 cell computaion = table build-up time**이 관심사. **for와 관련하여 계산하면 됨.**

if 0<k\<n 
경우의 수 n C k
 B[n, k] = 1 (if n\==k or k\==0)

T(n, k) = (1 + 2 + 3 + .. + k) + (k+1)\*(n-k+1) 
	= (k열까지 셀 계산 횟수 계속 증가) + (k+1번째 열부터 계산 횟수 k+1로 고정.)\*(n-k+1번 만큼 계산됨.)
		예를 들어 B[5, 3]를 계산하는데 B[5, 4], B[5, 5]까지 계산할 필요 없기 때문. 
	= k(k+1)/2 + (k+1)\*(n-k+1) 
	<= O(nk)
k^2이 식에서 나타나더라도 n이 더 크기 때문에 n이 수식을 지배

<br>

# Chained Matrix Multiplication (CMM) in Dynamic Programming
find an optimal order(=min # multiplications) for CMM

multiplying A = [p X q], B = [q X r]
		A X B = [p X r]

**chained matix multiplication (CMM)**
A 	     X 	B 	  X 	C     	X 	D
[20 2] 	[2 30] 	[30 12]  [12 8]
곱하는 방식(괄호를 묶는 방식)은
A(B(CD)) = 3680
(AB)(CD) = 8000 이상
A((BC)D) = 약 1000
((AB)C)D = 약 10000
(A(BC))D = 3000
...

다양한 방식이 있음. 가장 간단한 방법은 이 경우의 수를 모두 계산하는 Brute-Force
design : B&F = O(2^n)

Divide&Conquer의 경우 가장 적은 곱셈을 하는 optimal을 계산하면?
만약 10억개의 행렬이 있다면, 가장 적게 곱셈을 빨리 수행하려면?

**주어져있는 순서가 있는 matrix의 sequence가 있고, optimal 순서를 찾아야 함.** 
(minimum number mulitplications) for CMM

이 문제는 피보나치나 이항계수와 달리 주어진 수식이 없음. 
따라서
step 0 : examples (guessing)
	가장 쉬운 문제를 찾아 푸는 것으로 시작(hand computaion, 푼 문제를 저장하고 더 큰 문제를 풀어봄 : insight가 생김)
step1 : recursive property = recurrence (math. expression을 유도해야 함. 문제에서 수식이 주어지지 않은 경우 recursive property가 발견되어야 함.)
step2 : save / reuse

예시
```
A1 X A2 X A3 X A4 X A5 X A6
[5 2] [2 3] [3 4] [4 6] [6 7] [7 8]
-> 여기서 가장 쉬운 문제는 뭘까? A1 X A1 = 0 

--> 쉬운 문제? A2 X A3, A4 X A5, A5 X A6 : 두 개의 행렬을 곱하는 것
	A4 X A5 = 4X6X7
	A5 X A6 = 6X7X8
	...,
	풀었으면 저장해야 함. look-up table, 2차원 배열이 적합. 배열이름 M, 
	A4 X A5 = 4X6X7 -> M[4, 5]에 save
	A5 A6 = 6X7X8 -> M[5, 6]에 save
	순서에 어긋나면 계산(저장) 불가.
	...,
	
----> 그 다음 쉬운 문제는? 
	A4 X A5 X A6 : 세 개의 행렬을 곱하는 것
	1) (A4 X A5) X A6 = 4X6X7 + 4X7X8, 4X6X7은 이미 전에 한 계산의 결과에서 확인 가능. 
		M[4, 5] + 4X7X8 = P
		
	2) A4 X (A5 X A6) = 6X7X8 + 4X6X8,  6X7X8은 이미 전에 한 계산의 결과에서 확인 가능. 
		M[5, 6] + 4X6X8 = Q
		
	A4 X A5 X A6 = min(P, Q) -> requerence의 유도가 가능.
	...,
	
--------> A1 X A2 X A3 x A4 = M[1, 4]
	= min(M[1, 3]+alpha, M[2, 4]+betha, M[1, 2]+M[3, 4]+gamma)
	(A1 X A2 X A3)x A4
	A1 X(A2 X A3 x A4)
	(A1 X A2) X (A3 x A4)
	여러 셀을 참조하여 A1 X A2 X A3 x A4 값을 계산
	...,
	
--------------> 최종적으로 M[1, 6] = min
	M[1, 6]을 계산할 땐 5개의 셀을 참조하겠구나
	case1 : A1 X (A2...A6) 		= M[1, 1] + M[2, 6] + 5X2X8
	case2 : (A1A2) X (A3...A6)	= M[1, 2] + M[3, 6] + 5X3X8
	case3 : (A1...A3) X (A4...A6)	= M[1, 3] + M[4, 6] + 5X4X8
	case4 : (A1...A4) X (A5A6)	= M[1, 4] + M[5, 6] + 5X6X8
	case5 : (A1...A5) X A6		= M[1, 5] + M[6, 6] + 5X7X8
		
	requerence equation.
	M[1, 6] = min(M[1, k] + M[k+1, 6] + 5XC(k)X8) 
	C(k)는 k번째 matrix의 column.
	5는 첫번째 matrix의 row = 0번째 matrix의 column = C(0)
	8은 마지막 matrix의 column = C(6)
	k에 대한 범위 (for 1 <= k <= 5)
-------------------------------------------------------------------------------	
	위 수식으로 M[i, k]를 계산할 수 있어야 함.
	M[i, j] = min( M[i, k] + M[k+1, j] + C(i-1)C(k)C(j) )
		; (첫번째 matrix의 row=0번째 matrix의 column)*(k)*(마지막 matrix의 column)
	
	for (i <= k <= j-1)
		M[i, i] = 0
		
	위 Combination은 BF enumeration(2^n)이 아님.
	선형적으로 증가되는 조합의 개수만 가지고 있음.
	
	Dynamic Propramming(CMM)의 경우 linear한 개수의 combination을 가지고 있음. 
	(수가 많아져도 폭발적으로 증가하지 않음)
===> step0 완료.
	step1에 대한 recurrence equation이 유도된 것.
```
<br>

# Chained Matix Multiplication (CMM) Analysis
```
DP_CMM(input : matrix_sequence, dimensions_row_col)
{
	for i -> n
		for j -> n
			M[i, j] = recurrence : function of subproblems 
									;M[i, k] + M[k+1, j] + C(i-1)C(k)C(j)
			(for k=i -> j-1) ; min 계산
			
=> 총 for-loop을 세번 돎.
}
↓
DP_CMM(input : matrix_sequence, dimensions_row_col)
{
	for i -> n
		for j -> n
			for-loop(k)
...
			M[i, j]가 min()으로 return
}
자세한 코드는 교과서.   ==> 공간적인 낭비가 심해 code optimize 가능
```

### Time complexity : A1XA2X...An
각 셀의 계산 횟수를 구하면 됨.

B[n, k] => O(nk)
T(n)  = O(n^2) * time/subproblem
( time/subproblem을 계산하는 데에 조합을 여러번 봐서 minumum을 찾아야 하기 때문에 
for k=i -> j-1 보아야 함. -> k -> n(최대 n번) )
	= O(n^2) * n -> O(n^3)
	= # subproblems * time/subproblem 
교과서에 자세하게 나와있음.

DP로 문제 A를 디자인했다면,
A에 대한 recurrence eauation을 유도했을 것.
A에 대한 분석 후
DP에선 code optimization이 필요하다. for running time for A