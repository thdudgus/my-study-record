### Table of Contents
1. [[#연결 (connectivity)|연결 (connectivity)]]
2. [[#요구사항|요구사항]]
3. [[#네트워크 구조|네트워크 구조]]
4. [[#성능 (performance)|성능 (performance)]]

----

# 연결 (connectivity)
통신망이 해야하는 제1 업무
- **통신 주체**
	전화기 등 단말기, 통신응용
- **연결 방법**
	유선/무선
- **통신망 구성 요소**
	노드 : 단말기 범용 워크스테이션, 라우터 등 : 통신 중간에서 통신을 도와주는 것들
	링크 : 동축케이블, 광케이블, 무선 채널 등 : 연결에 이용되는 선의 개념
인터넷(컴퓨터) 상으로는 host도 노드. 
terminal도 노드가 될 수 있음.

# 요구사항
### 직접 링크 (Direct link)
- **점대점 연결 (point to point)**
- ![[Pasted image 20241019161150.png|300]]
	한계 : 불특정 다수 사이 통신에 대해 비효율적이고 현실성이 떨어짐. 노드가 많아지면 링크가 기하급수적으로 많아짐
- **다중 접근 (multiple access)** (LAN 기반)
- ![[Pasted image 20241019161215.png|300]]
	한계 : 링크 비용이 줄지만, 복잡하고 신호 충돌의 가능성이 있다. 어떤 노드가 언제 얼마나 링크를 사용할지 고려가 필요.

### 간접 연결 (Indirect connectivity)
Switched networks
- **스위칭 네트워크 (switching networks)** : 중간 노드들의 핵심이 스위칭이고 내부적으로 스위칭이 일어남. 중간중간 요소에 노드를 붙인 형태
	![[Pasted image 20241019161308.png|200]]
	- 회선 스위칭 (circuit switching) : 전화 네트워크
		- 스위치가 사전에 전용 회선(용량) 확보.
		- 비트스트림을 중단/간섭 없이 송수신
		- 기본적으로 point to point
		- Bursty가 문제 => 전용을 깨야 함. => 묶어서 패킷스위칭
	- 패킷 스위칭 (packet switching) :인터넷/우편
		- 링크를 사전 할당하지 않고, 데이터를 묶음으로 전송(패킷)
		- 스위치 동작 : 패킷마다 store and forward
		=> 처리량을 얻고 품질을 잃음.
	둘 중 컴퓨터통신에 적합한 것은 사용자 입장과 네트워크 입장에서 다름. 
	사용자 입장에선 회선 스위칭이 서비스 품질이 좋음
	네트워크 입장에선 비용이 낮은 패킷이 좋음.
	그러나 QoS가 더 중요.
- **인터네트워크 (internetworks)**
	![[Pasted image 20241019161346.png|200]]


### 어드레싱 (Addressing) 및 라우팅 (Routing)
주소 (address) : 노드를 식별하는 바이트열 (대개 유일)
라우터 (router) : 많은 네트워크로 이루어진 인터넷에서, 목적지 네트워크까지 가는 경로
- **주소의 종류 (=연결 형태)**
	- 유니캐스트 : 특정 노드 지정 (1:1)
	- 방송/브로드캐스트 : 네트워크의 모든 노드 (1:all)
	- 멀티캐스트 : 네트워크의 일부 노드 집합을 지정 (1:N)
ing를 붙이면 해당 형태로 통신함을 의미 (multicasting)
=> 주소로 연결 패턴을 명시 : unicast address (특정한 하나를 지정하는 주소), broadcast address (전부를 지정하는 주소)


### 비용 효율적인 자원 공유 (Resource sharing)
노드와 링크는 한정적이기 때문에 여러 사용자들이 네트워크 자원(노드 및 링크)를 공유하도록 해야 한다.
**다중화 (multiplexing)** 지원
![[Pasted image 20241019163048.png|500]]
	- 주파수분할 다중화 (FDM) : 주파수를 기준으로 분할
		- 각 주파수 영역 사이의 gap이 있어 전체를 다 못 쓰는 단점이 있음.
		- 아날로그의 성격
	- 시분할 다중화 (TDM) : FDM의 보완, 주파수를 나누지 않고 전체를 다 사용. 시간 기준으로 분할
		- 통계적 다중화 (Statistical multiplexing) :동적 분할, 비동기식 다중화(async TDM(on-demand))
		![[Pasted image 20241019164111.png]]
		sync가 최선인 경우는 input이 끝없이 있는 경우이다. overhead가 없기 때문.
		async가 최악인 경우는 input이 끝없이 있는 경우이다. overhead가 있기 때문.
		=> 그러나 대부분의 경우에선 통계적 다중화가 효율적.
	

### 통계적 다중화와 패킷스위칭
통계적 다중화 : 여러 연결이 링크를 공유하는 것.
패킷 스위칭 : 목적지를 향해 데이터를 보내는데 이를 스위칭하는 것.
=>이 둘이 다르기 때문에 분리가 필요
**링크에서 통계적 다중화를 하려면 노드에서는 패킷 스위칭이 필요**
다른 출발지/source로부터의 패킷들이 링크에서 섞이게 됨.
링크로 나가기 위해 경쟁하는 패킷들을 저장 : 버퍼링
버퍼 오퍼블로우 = 혼잡 (congestion)
![[Pasted image 20241019164827.png]]


#### 회선 스위칭과 패킷 스위칭

|                   | **circuit switching**                  | **packet switching**                                          |
| ----------------- | -------------------------------------- | ------------------------------------------------------------- |
| **연결 전**          | 스위치가 사전에 전용회선을 확보                      | 사전 작업 없음                                                      |
| **연결 후(데이터 전송)**  | 비트스트림을 중단/간섭 없이 송/수신<br>point to point | store & forward<br>: 패킷을 버퍼에 담고 sequential한 동작으로, 주소를 보고 보낸다. |
| **사용자 (host) 관점** | 좋음.<br>남들과 안 섞이는 전용회선으로, QoS가 일정       | 안 좋음. 스위치 동작 : store & forward => QoS 일정하지 않음.                |
| **네트워크 관점**       | 안 좋음.<br>전용 회선이므로 여러 작업을 한 번에 하지 못 한다. | 좋음.<br>여러 작업을 한 번에 할 수 있다.                                    |
| **Qos**           | 일정 (전용회선으로 중단/간섭이 없기 때문)               | 보장 x (사용자가 붐빌 시 품질 하락)                                        |

### 통신 서비스 제공
통신의 주체는 응용 프로그램
호스트 간의 연결을 프로세스 간의 통신 형태로 변환.
네트워크는 프로세스와 프로세스 간의 channel을 지원.

### 통신 장애 극복
- 네트워크가 정상적으로 작동하지 않는 경우
	- 비트 수준 오류
	- 패킷 수준 오류
	- 링크/노드 고장
	- 메시지 지연
	- 메시지의 순서가 바뀌어 전달 (out of order)
	- 도청

# 네트워크 구조
### 프로토콜(Protocol)
통신에 사용되는 약속 (**양쪽이 대칭 관계**)
- 다양한 컴퓨터통신 시스템/응용 => 복잡성을 해결하는 구조적 기법 필요 
=> **계층화 (Layering)**
	복잡한 문제를 단순하게 => 추상화(abstractions)
	recursive한 추상화 적용.
	추상화가 계층화를 유도.
**통신 프로트콜을 여러 계층으로 정의**

### 프로토콜 계층/개체
- (전체)프로토콜 구성 계층 (구성 요소)
- 자체도 프로토콜
- 인터페이스
	- 서비스 인터페이스 (service interface) : 해당 프로토콜의 작업을 정의 (ex. API)
	- 동료 인터페이스 (peer to peer interface) : 동료 간에 교환되는 메시지를 정의 (ex. message/header format)

### 프로토콜 그래프 (프로토콜 스택)
- 프로토콜의 collection과 그들 사이의 dependency
- peer(동료)간의 통신은 대개 간접적
	- 실제 통신은 하위 계층을 사용하여(위임하여) 이루어짐.
	- 하드웨어 수준에서만 peer 간 직접적
![[Pasted image 20241019171635.png]]


### 계층적 프로토콜에서 통신이란?
- 논리적 : 응용과 응용 사이, peer간 통신
- 물리적 : 실질적으론 하위 계층으로 내려보냄(send down)
 연속적으로 recursive하게 진행되다가 하드웨어적으로 연결되며 통신.
동작 원칙 : 포장/캡슐화(encapsulation) : header / body, 받을 땐 decapsulation
![[Pasted image 20241019172101.png]]
header에 따라 일이 다르다. 다른 header가 오면 수신쪽 코드가 달라짐.
실제 동작
	- peer to peer interface : message/header format
		header format에 관함 : header = adress + demux key + ... +의 약속이 필요.
	- service interface : function signature (예. API)

### 추상화/계층화
i계층에서 뭘 받아서(i+1) 사용하고, 뭘 보내야(i-1) 하는지 알고 문제를 해결해야 함.
-  추상화 : 기능이 있다고 가정 => 기능 문제로부터 해방
- 계층화 : 하위계층이 제공하는 기능을 이용하고 주어진 기능을 구현하여 상위 계층에 제공
##### 통신에서 계층화는 필수
- 통신을 필요에 따라서 추상화가 된 logical 관점/구체화가 된 physical 관점
- 전체 프로토콜은 프로토콜 계층 구조로 정의 (스택)
- 각 계층의 프로토콜은 peer-to-peer / service interface(시스템 구현에 필요)

### 표준 구조(Standard Architecture) (1)
- Open Systems Interconnect (OSI) Architecture
7계층
- **(7계층) 응용 계층** : 응용 자체와 관련된 사항
- **(6계층) 프레젠테이션 계층** : 데이터 표현 방법
- **(5계층) 세션 계층** : 대화 패턴
- **(4계층) 트랜스포트 계층** : 통신 ==응용== 사이의 ==신뢰성 있는== 메시지 
	(==end-to-end reliable== data transfer : process간 channel 제공)
peer 관계에서 1~3 계층은 있어야 함 (reliable하진 않음= unreliable)
- **(3계층) 네트워크 계층** : ==네트워크==를 통해 연결된 ==호스트==(단말) 사이의 ==패킷==(data) 교환
	(==host-to-host unreliable== data transfer)
- **(2계층)링크 계층** : ==하나의 링크==로 연결된 ==노드== 사이의 ==프레임(bit 묶음)== 교환
- **(1계층) 물리 계층** : 물리적 신호(bit) 교환

### 표준 구조 (Standard Architecture) (2)
- 인터네트(internet) 구조
	 - Internet Engineering Task Force (IETF)
	 ![[Pasted image 20241019180753.png]]
	 - 응용 및 응용 프로토콜 (FTP, HTTP)
- 특징
	- 계층화를 그대로 따르지는 않음
	- 모래시계 형태의 모양
	- 설계와 구현을 병행하여 진행

### 계층이 많은 것은 장점인가? 단점인가?
- 계층이 많을수록 각 층 자체가 얇아 구현이 쉽다. 그러나 효율이 떨어진다. (비용이 많이 듦.)

# 성능 (performance)
### 대역폭
대역폭(bandwiidth)                           -- 처리량/처리속도(throughput)
실질 처리량보단 최대속도(capacity) -- 실질 처리량
대역폭 : BPS => 단위 시간 당 전송될 수 있는 데이터의 양 (Bit Per Second)
![[Pasted image 20241019181457.png|400]]
KB = 2^10 
Mbps = 10^6 bits/per second
속도가 높아지면(빨라지면) 비트폭은 작아진다. 주파수가 커진다. 고주파. 대역폭 증가
속도가 높아지면 비트 사이가 좁아진다. 주파수가 작아진다. 
![[Pasted image 20241019202416.png|500]]
주파수가 높으면 투과성이 떨어지게 됨.
ex) 4G와 5G의 경우 후자의 속도가 더 빠르지만 투과성이 떨어짐. 
- 비트폭이 좁아지면 여러 문제가 생김

### 소요시간(Latency)/지연시간(Delay)
a에서 data를 보내고 b가 data를 받는 데까지 걸리는 시간

때론 왕복 지연 시간(round trip time : RTT)이 중요할 수 있음.
- **소요시간 = Propagation(전파지연시간) + Trasmit(전송시간) + Queue[+스위칭 시간]**
Propagation(전파지연시간) = 거리/광속
Trasmit(전송시간) = 보내려는 양/대역폭

소요시간(Latency) = (거리/광속) + (보내려는양/대역폭) + Queie[+스위칭 시간]

- 직접링크에서 queueing delay는 없음.
### Timing in Circuit switching
![[Pasted image 20241019212528.png]]

### Timing in Packet switching
![[Pasted image 20241019212541.png]]
![[Pasted image 20241019212631.png]]


### Packet Segmentation : pipelining
![[Pasted image 20241019212610.png]]


### 성능은 대역폭과 소요시간의 상대적 중요성에 따라 다르다.
data size가 작은 메시지는 소요시간이 중요.
data size가 큰 메시지는 대역폭이 중요.

- 무한대 대역폭인 경우
총 소요시간이 중요.
**Throughput = TransferSize/TransferTime(전송완료시간)**
회선 스위칭 : TransferTime = RTT(왕복 지연 시간) + (TransferSize/대역폭)
패킷 스위칭 : 여러 요소의 영향

### 대역폭 * 지연시간 (==Bandwidth * Delay== Product : BDP)
**양 end point 간 data의 최대 처리량.**
즉, **데이터를 보냈는데 상대편에서 아직 안 받은, 이동 중일 수 있는**(in flight or in the pipe) **데이터**의 최대/적정 양
- bit로 나타내는 링크의 길이 (bit length)
	- 링크의 부피
	- 대역폭이 반영된 지연시간
	ex) 100ms * 45Mbps = 560KB
	![[Pasted image 20241019204811.png]]
	
	

### 기타 사항
- **응용의 요구사항**
	- 짧은 시간 동안 매우 많은 양의 데이터가 갑작스럽게 전송되는 버스트(burst) 상황도 네트워크가 허용할 수 있는 최대 전송 속도(peak rate)를 함께 고려해야, 트래픽이 몰려도 성능 저하가 최소화가 된다.
	- **패킷** 사이의 차이로 패킷 도착 간격이 불규칙해지는 **jitter현상**을 줄여야 실시간 데이터 처리가 원활하다.
- **기타 주의 사항**
	- 데이터 양이 너무 작으면 대역폭은 의미가 없음. => 안정성이나 지연이 더 중요한 요소
	- 응용 프로그램의 데이터 처리 시간
	- 거리가 짧고 고속 통신이면 소프트웨어 부하가 중요 요소

### 통신 성능을 높이는 방법
- **처리량(대역폭)을 높이는 방법**
	-  한번에 보내는 양을 높인다
	- 고속 도로/차선
	- **채널을 넓힌다.** 
- **소요시간(지연시간)을 줄이는 방법**
	- 신호(전파/광파)의 속도를 높일 수는 없다.
	- 지역 처리를 높여서 **실질적인 거리를 줄인다.**
	- 트래픽을 조절 => **큐잉대기시간을 줄인다**
	- 통신 **소프트웨어**의 속도 개선