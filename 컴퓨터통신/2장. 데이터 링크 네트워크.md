### Table of Contents
1. [[#점대점(point to point) 링크|점대점(point to point) 링크]]
2. [[#신뢰성 있는 전송|신뢰성 있는 전송]]
---

# 점대점(point to point) 링크
## 데이터 링크 계층
**OSI 7계층의 1, 2계층**은 하나의 링크로 연결된 노드 사이의 **비트 묶음(프레임) 교환**
- 하나의 링크로 연결된 두 노드
	- **점대점 연결 네트워크**: 가장 간단한 네트워크
		- 비트 교환
		- 비트 묶음 교환
		- 오류 검출/복구
	- 일반적 네트워크 구성의 기본 block
- 노드
- 링크

## 하드웨어 구성요소 노드(Nodes)
- 단말/호스트, 스위치/라우터
- 시작과 끝 : 호스트, 라우터
- 중간 : 스위치, 라우터
- 범용(프로그래밍 가능한) 컴퓨터로 구성된다 가정 or 특수 목적의 하드웨어
![[Pasted image 20241020005433.png|400]]
- **유한 메모리**(제한된 버퍼 공간)
- **네트워크 어댑터**(or **NIC** : Network Interface Card)를 통해 네트워크에 연결
- **프로세서**는 빠르고 **메모리**는 느림 (메모리나 버스가 병목)

### 링크(Link)
**노드와 노드 사이에서 데이터(신호) 전달을 위한 물리적 매체** (케이블, 공기,...)
- **유선/무선**
- **전송모드**
	- simplex
	- half-duplex (ex. 무전기)
	- full-du동통신 (cellular networks)
- 링크는 논리적 통로 : 하나의 케이블에 여러 링크 (ex. ADSL : 전화선을 이용한 인터넷 링크)
- **기지국과 단말기**
	- 셀
	- 핸드오프(hand-off) 문제
- 기술 발전
	- AMPS -> PCS(GSM/CDMA) -> W-CDMA	-> 4세대 이동통신 -> 5F

### 사용 가능한 유선 링크 종류
![[Pasted image 20241020142444.png]]
거리의 영향을 많이 받음.

#### 광케이블 : Optical Fiber
![[Pasted image 20241020142536.png]]
core(빛이 통과하는 통로)

#### 가입자 선로 (Last-Mile Links)
가입자 망
- 집(사용자)과 인터넷 공급자 사이를 마지막으로 연결하는 링크
- 사용자가 선택해서 사용하는 링크!
- 과거는 모뎀을 통한 음성 전화 링크 사용.
- xDSL(Digital Subscriber Loop) : 음성과 data를 FDM 방식으로 동시에
	![[Pasted image 20241020142851.png|600]]
- Cable Modem
![[Pasted image 20241020143054.png|550]]

### 모듈레이션 : ==데이터의 신호화==
- **데이터를 링크를 통해 전달하기 위해 모듈레이션**
- 인코딩/모듈레이션 : 데이터(이진수) -> 신호
- 수신쪽에선 demodulation : 신호 -> 데이터(이진수)
- 모뎀(modem) : modulation, demodulation하는 장치
- 신호 종류 : 전자기파 스펙트럼
	![[Pasted image 20241020142122.png]]
	저주파일수록 전송 특성이 좋지만(투과성 높음), 고속 데이터 전송에 한계
	통신의 발전은 저주파에서 고주파로 이루어짐.
- 주파수(Hz), 파장(wave length)


### 무선 링크
**장점**
- 고정된 링크가 없음
- 이동성 지원
- 즉시 사용 가능
**단점**
- 공중으로 퍼져나감(통제가 안 됨)
- 고주파가 필수
- 인접한 링크 사이 간섭 발생 가능성 => 전파 사용 규제 필요(라이센스 제도)
- multipath problem : 무선이 점점 고속이 되는데, 신호가 송신점에서 직선으로 수신될 수도 있지만, 여기저기 튕겨서 수신될 수 있음 => 간섭 가능성이 높아짐

#### 이동통신 (Celluar Networks)
- 기지국과 단말기
	- 셀 : 한 기지국의 관할 지역
	- 핸드오프(hand-off) 문제 : 단말기가 이동함에 따라 셀을 넘어가게 되면 통신이 끊기는 문제
- 기술 발전 : AMPS -> PCS(GSM/CDMA) -> W-CDMA -> 4세대 이동통신 -> 5G
![[Pasted image 20241020144529.png]]


#### 고정 무선 통신 (Wireless Fixed Links)
![[Pasted image 20241020144736.png]]

#### 위성 통신(Satellite system)
![[Pasted image 20241020144800.png]]


#### 단거리 무선 통신(Short range)
![[Pasted image 20241020144842.png]]


## 인코딩 (modulation의 일종)
**신호(signal)는 물리적 매체를 통해 전달됨**
- 디지털 신호
- 아날로그 신호

**데이터는 디지털 데이터만 취급**
- 따라서 아날로그 데이터를 디지털 데이터로 변환
문제 : 발신지에서 목적지로 보내려는 **==이진 데이터를 전달될 수 있는 신호로 인코드==**해야 함. => modulation
![[Pasted image 20241020145016.png|400]]


### 디지털 전송(transmission)
- **신호 중계 방법 (통신망 안에서의 전송 방법)**
	- **아날로그 전송** : amplifier를 사용한 신호 단순 증폭 (원래 신호도 확장되지만, 노이즈도 확장)
	- **디지털 전송** : 신호에서 데이터를 복원하여 다시 신호화(디지털 데이터를 담은 신호만 사용가능 => repeater 사용)
	- 거의 모든 전송 방법이 디지털 전송 사용 : noise 제거, 기기 비용, 부가 기능 추가 기능
#### 데이터 전송 (Transmission)
![[Pasted image 20241020145314.png|500]]

### PCM (Pulse Code Modulation)
- **Sampling Theorem** : 최대 주파수 f_m을 갖는 연속 신호를, 2f_m 이상으로 sampling하면 손실이 거의 없이 복원할 수 있다.
![[Pasted image 20241020145422.png|400]]
![[Pasted image 20241020145516.png|600]]

### 변조 : Amplitude Modulation (AM)
신호를 amplifier하여 신호 구분
![[Pasted image 20241020145620.png|600]]
![[Pasted image 20241020145924.png]]

![[Pasted image 20241020150110.png|500]]
##### 음성 데이터의 디지털 전송
![[Pasted image 20241020150351.png]]

### 주파수 변조 : Frequency Modulation (FM)
신호의 주파수를 바꿔 modulation
![[Pasted image 20241020145711.png|600]]


### 위상 변조 : Phase Modulation (PM)
shift
![[Pasted image 20241020145802.png|600]]


### Non-Return to Zero (NRZ)
![[Pasted image 20241020151434.png|500]]
- 노드 내부의 데이터 표현과 일치 (즉, **별도의 인코딩이 필요 없음**.)
- **문제점 : 1 또는 0이 연속되는 경우**
	- low signal(0) : 수신자가 신호가 없는 것으로 오해 가능
	- high signal(1) : 전류가 계속 흐르게 되고, 기저 전압의 혼돈 야기
	- clock 복구 불가능
		- 서로의 clock이 달라 잘못된 비트 인식
		- 수신자가 송신자의 clock에 자신의 clock을 맞추는 작업
	송신자와 수신자의 clock이 같지 않기 때문에 발생하는 게 NRZ의 치명적인 문제

### NRZI and Manchester
![[Pasted image 20241020151501.png|500]]
- **NRZI (Non-Return to Zero Inverted)**
	1을 인코드할 경우, 현재의 신호로부터 중앙 지점에서 전이(mid transition)
	0을 인코드할 경우, 현재의 신호 상태 유지 => 연속되는 1의 문제 해결, 0의 연속 문제는 해결 X
- **Manchester** 
	0:up transition, 1:down transition
	**NRZ 방식으로 인코드 된 데이터**와 **clock**을 **XOR** 시켜서 바꾼다. (data에 clock을 얹어 동시에 보내는 것. 코드 복구가 가능)
	=> clock 문제점 해결
	==> 효율이 50%
#### mid-transition이란?
0이면 현재 값 유지
1이면 클락 비트폭의 중앙 지점에서 바꿈
=> 1의 연속 문제는 해결
==> 0의 연속 문제는 해결 X
- **Manchester code 예시**
송신쪽에서 data에 clock을 얹어서 보내면 수신된 쪽에선 data를 인식 후, 전송 중 오류가 없다 가정. 
**전송된 (data⊕colck)에 다시 data를 ⊕(XOR)하면 clock을 꺼낼 수 있다**. => 동기화 가능.
![[Pasted image 20241020154028.png]]


### 4B/5B
0의연속을 나오지 않게 하기 위함. (0 연속 최대 2개, 최악의 경우 앞 1개, 뒤 2개가 0)
- **데이터를 매 4bit마다 5bit 코드로 인코드 한다.**
	(0이 4개 이상 연속된 수는 나올 수 없다.)
- **5bit 코드는 NRZI 인코딩을 이용하여 전송된다.**
- 효율 80%
![[Pasted image 20241020155727.png|300]]

## Framing
데이터를 끝없이 보낼 수는 없음. (특히, 패킷 네트워크에서)
**문제**
- 비트들의 연속을 하나의 frame으로 자르는 것
- 수신 쪽이 프레임을 인식할 수 있도록 봉투를 씌워서 묶는 것
- 프레임의 처음과 끝 인식

전형적으로 네트워크 어댑터에서 구현됨.
![[Pasted image 20241020155914.png|500]]
어댑터는 송신 경우, 호스트 메모리로부터(data + header 일부분)을 가져와서 frame을 만든다. 
=> encapsulation

### 바이트 중심 프로토콜 (byte oriented protocols)
protocol message (Protocol Data Unit, PDU) format.
(peer 인터페이스의 실체)
![[Pasted image 20241020155959.png|600]]


### 비트 중심 프로토콜 (bit oriented protocols)
![[Pasted image 20241020160127.png]]
## 오류 검출 
### 오류 검출 코드 (EDC : Error Detection Code)
데이터 영역 안에 오류가 있는지 없는지를 알아내는 부가데이터(데이터와 함께 추가로 보냄)
ex) parity
**조건**
1. 크기 면에서, EDC << data : 오류가 없는 경우 단순 부하이기 때문.
2. 효율 면에서, 오류 검출율이 높아야 함.
3. 비용 면에서, f() 연산에 시간이 적게 소모돼야 함.
![[Pasted image 20241020160422.png|400]]


#### 오류 검출율
> EDC가 완벽하게 오류를 검출할 수 있을까?

오류 검출에 실패한다면, 시스템 integrity 상실
- 에러가 있을 수 있음. (에러가 있을 확률을 줄이는 것이고, 에러 검출에 실패할 수 있음.)
	=> 그렇기 때문에, 매우 높은 오류 검출율 + 중복해서 오류 검사
![[Pasted image 20241020160815.png|600]]

#### 2차원 패리티
1 bit가 오류라면, 그 위치를 detect할 수 있고 correction도 가능한 장점.
그러나 검출율은 낮음.
![[Pasted image 20241020160945.png|150]]


#### 인터넷 체크섬 알고리즘
메시지를 16-bit의 정수의 연속으로 간주.
각 정수들을 16-bit 1의 보수 연산을 사용하여 모두 더한다. (다 더하면 0이 됨, 1의 보수는 carry를 살리기 위해 사용)
그리고 그 **결과의 1의 보수**를 얻는다. 이 16-bit 숫자가 체크섬(checksum)이다.
=> 더블 체크용
![[Pasted image 20241020161151.png]]


#### 순회 중복 검사 (==CRC== : Cyclic Redundancy Check)
전송되는 데이터의 오류 여부 확인을 위해 **부가 되어**(얹어져서) 보내지는 오류 검출 코드

송신자가 계산에서 추가, 수신자가 확인.
더하기 보다 복잡한 **나누기 사용** : 나머지를 오류 검출 코드로 전송. (XOR-나누기 연산 기초)
- frame 전체가 약속된 제수C로 나누어지도록, CRC 값을 만들어서 이를 데이터 뒤에 붙여 전송.
	- 나머지가 0이 아니면 오류, 0이면 오류가 아니라 간주
- **C : 제수**(나누는 수)로 사용될 송수신 사이에 약속된 비트 패턴
- **M : 보낼 메시지**
- **F (즉, EDC)** : 오류 검출을 위해 추가되는 정보
![[Pasted image 20241020161433.png|150]]

오류 검출율이 매우 높고 하드웨어 구현 가능
=> 거의 모든 링크 전송에서 사용.

**송신**
- ( M || F ) % C = 0 이 되도록 F를 생성
	- 즉, (F에 나머지를 넣어서) 전체 프레임이 C로 나누어 떨어지도록 함.
- ( M || F ) 를 전송
- 예) C=1101, M= 10011010 이면, 
		F = **101** 를 생성 (10011010**101**은 1101로 나누어 떨어짐)
		10011010**101** 전송

**수신**
수신된 메시지 전체를 C로 나누어서,
나누어 떨어지지 않으면 => 오류 발생
나누어 떨어지면 => 오류가 없는 것으로 간주

**오류 검출율**
- **나누는 수 C의 비트 패턴을 어떻게 선택하느냐**에 따라 좌우됨
- 수학적 분석에 의해 잘 잡으면, 또는 32비트 코드 사용하면 1500byte 이상의 데이터에 대해서도 매우 높은 검출율

**연산 속도** => **전송 속도 빠르거나, 적어도 같아야 함.**
- 전송 가능 속도보다 늦으면 CRC 계산이 끝나는 시간이(연산속도가) 전송 시간을 결정.
- 가능하면 네트워크 어댑터(NIC) 내에서 하드웨어로
빠른 연산과 분석을 위해 다항식 연산 (⊕)을 사용
C값에 대해 송수신 쪽이 합의해야 함 => **표준화된 C 사용 ("CRC Code")**

**송신자 세부 사항**
![[Pasted image 20241020163409.png]]

**Error Pattern : E(x)**
![[Pasted image 20241020163436.png]]


**수신자 세부 사항**
==수신된 frame = 송신frame + error pattern==
![[Pasted image 20241020163511.png|600]]


**CRC Code**
CRC는 대표적인 오버헤드로 줄여야 함.
그러나 CRC가 길수록 오류 검출율이 증가함.
=> 보내는 데이터 크기와 요구하는 오류 검출율에 따라 CRC를 조절하면 됨.
![[Pasted image 20241020163647.png|500]]

**CRC의 하드웨어 구현 (참조)**
![[Pasted image 20241020163818.png|600]]
**CRC는 전송하면서 계산이 동시에 이루어지기 때문에 프레임 끝에 오게 된다.**
만약 CRC가 헤더에 들어가려면 전송 전 미리 계산이 이루어져야 한다.

# 신뢰성 있는 전송
## 개요
오류에 의해 변질된 프레임 복구 (CRC로는 오류 detection만 가능)

- 오류 수정 코드 (ECC), ; 오류가 나지 않으면 쓰지 않음. overhead가 많고, 오류 수정이 안 될 수 있음.
	- 순방향 수정 (FEC: Forward Error Correction)

ECC의 대안으로 자동 반복 요청이 있음. (**ARQ** : Auto Repeat reQuest) : **재전송**
2계층 기능이지만, 노드 내 소프트웨어로 처리
- ACK와 타임아웃 (재전송용 버퍼 처리도 필요)
- 역방향 수정 (**BEC** : Backward Error Correction). ; 오류가 많이 나고 재전송이 가능한 상황에서 사용.
	ex) 은행 같은 곳은 100% 오류가 고쳐져야 하기 때문에 FEC 사용 불가. 
	전화와 같이 실시간인 경우는 재전송 하는 데에 시간이 소요되어 부적절한 경우가 있음

### ARQ : ACK와 timeout
오류 복구 후, 정상 전송까지 확인
송신자, 수신자를 개별적으로 생각하기 (예측 ㄴㄴ)
송신 : 모든 데이터 프레임에 식별자 부착
수신 : 모든 ACK 응답에 수신된 데이터의 식별자 표시
![[Pasted image 20241020170539.png]]
![[Pasted image 20241020204424.png|500]]
- ACK에 순서번호 (frame ID) 필요 : 중복 data 방지 : 프레임과 ACK 모두 부착 (헤더의 일부분)
- 수신자 : **수신된 중복 data는 discard, ACK는 반드시 전송.**
![[Pasted image 20241020171048.png]]
#### 정지 대기 (stop and wait)
ARQ의 효율이 떨어진다.
outstanding frame의 개수가 하나로 window size가 1이다.
== ACK를 받지 않은 상태에서 보내지는 frame의 수는 1
![[Pasted image 20241020171856.png|550]]

### 슬라이딩 윈도우
파이프를 채우기 위함.
![[Pasted image 20241020172058.png|600]]
**성능**
![[Pasted image 20241020172126.png|600]]

**표기**
![[Pasted image 20241020172230.png|600]]

![[Pasted image 20241020172320.png]]
위 이미지에서 ACK3은 F0~F3까지의 누적 ACK임.


![[Pasted image 20241020172334.png]]

#### Go-back-N 
**구현의 옵션 사항**
![[Pasted image 20241020173733.png|600]]

![[Pasted image 20241020174033.png]]

![[Pasted image 20241020174335.png]]
**Go-back-N 구현**
- 송신/수신 각각 독립적으로 동작
- 송신쪽 동작
	- 오류 제어 : 각 [[outstanding frame]]에 대해 
		- 재전송 버퍼에 저장, 타임아웃 설정
		- ACK 받으면 타임아웃 해제, 재전송 버퍼 해제
		- 타임아웃 발생하면 재전송
	- (버퍼+윈도우) 관리
- 수신쪽 동작
	- 오류 제어: (누적) ACK 전송
	- 버퍼 관리 : ([[out of order frame]]은 저장은 하고, ACK는 따로 보내지 않는 방식)

**Go-back-N 세부 알고리즘**
![[Pasted image 20241020193730.png]]
![[Pasted image 20241020193745.png]]



#### Selective-Repeat
빵꾸난 놈만 채우자! 
누적 ACK 안 됨. ==**개별 ACK**==!!
![[Pasted image 20241020174705.png]]

#### 다른 오류 복구 정책의 상호 운영성
- 송신과 수신이 서로 다른 오류 정책을 사용한다면 연동이 되나?
	상대방과 세부 정책이 다르면 통신이 불가한가?
=> **하지만**, 궁극적인 목적은 **오류 복구**이며, 각기 다른 정책을 사용하더라도 **오류 복구가 성공적으로 이루어지고 통신이 진행된다면 연동이 가능**하다고 볼 수 있다.


#### 세부 사항
Sliding Window는 효율 높은 오류 제어 프로토콜
- 각각의 [[outstanding frame]]에 대해 기본적으로 ARQ 수행 (개별 타임아웃에 대해)
- 복수 개의 [[outstanding frame]]의 처리를 위해 buffering 추가

| 오류 복구 방법<br>(선택은 송신자 결정） |                                                                               |                                 |
| ------------------------ | ----------------------------------------------------------------------------- | ------------------------------- |
|                          | **Go-back-N**                                                                 | **Selective-Repeat**            |
| **sending buffer**       | 필수(재전송)                                                                       | 필수(재전송)                         |
| **receivnig buffer**     | 성능 향상을 위한 option                                                              | 필수<br/>(out of order 프레임 반드시 저장 |
|                          | 수신자가 out of order를 <br>저장한다고 selective repeat은 아님.<br>ACK#n의 의미가 오류 복구 약속의 핵심 |                                 |
| **ACK**                  | 누적ACK                                                                         | 개별 ACK                          |
누적 ACK가 잘 받은 거까지만 보내고, 못 받은 frame 후론 ACK 보내지 말고 기다리다가 제대로 오면 다시 보내기. 
개별ACK는 개별로 보내기.

송신자의 재전송 방법; 수신자의 적절한 응답 필요
수신자의 buffering은 별도 문제(송신자가 구현 옵션이 달라도 Go-Back-N 원칙만 지키면 문제 없음.)

송신자가 selective-repeat하기 위해서는 수신 상황 정보가 필요.

