### ☆ 대표적 병행성 기법 (common concurrency mechanisms)
- 세마포어 ([[semaphore]])
- 이진 세마포어 ([[binary semaphore]])
- 뮤텍스([[mutex]])
- 조건 변수 ([[conditional variable]])
- 모니터 ([[monitor]])
- 이벤트 플래그 ([[event flag]])
- 메일박스/메시지 ([[mailbox, message]])
- 스핀락 ([[spinlocks]])
<br>
**운영체제와 프로그래밍 언어 수준에서 병행성을 제공하는 기법** 중 하나인 다익스트라 기법의 기본적인 원리는 한 프로세스가 특정 시그널을 수신할 때까지 정해진 위치에서 중지하도록 강제하는 것. (두 개 이상의 프로세스들이 간단한 형태의 시그널을 이용해 협동.)   
좀 더 복잡한 프로세스들 간의 상호작용에 대한 요구 조건도 적절한 구조의 시그널을 이용하면 만족될 수 있다.
=> **시그널을 위해 세마포어라는 특수 변수들을 사용**한다.

### ☆ Semaphore Primitives
semWait와 sem-Signal primitive는 각 primitive가 수행되면 완료될 깨까지 중간에 다른 프로세스가 어들 수 없다. 
세마포어는 유지할 수 있는 값의 범위에 따라 이진 세마포어와 범용 세마포어([[general semaphore]], counting semaphore)로 구분된다.

general semaphore
```
struct semaphore {
	int count;  // 세마포어의 현재 값, 사용가능한 자원의 수 또는 대기 중인 프로세스 수
	queueType queue;  // 세마포어에 의해 자원을 기다리고 있는 프로세스 관리를 위한 대기열
};
void semWait (semaphore s)
{
	s.count--;  // 세마포어 값 감소 (0보다 작아지면 자원이 없다는 의미.)
	if (s.count < 0){   // 자원이 부족하면
		// 요청한 프로세스를 s.queue(대기 큐)에 연결.
		// 요청한 프로세스를 블록 상태로 전이시킴.
	}
}
void semSignal (semaphore s)
{
	s.count++;  // 세마포어 값 증가 (0 이상이면, 대기 큐에 있는 프로세스 중 하나를 깨워 실행 가능 상태로 만들 수 있다는 의미.)
	if (s.count >= 0) { // 자원이 다시 사용가능한 상태가 되면
		// s.queue에 연결되어 있는 프로세스를 큐에서 제거.
		// 프로세스의 상태를 실행 가능으로 전이시키고 ready list에 연결.
	}
}
```
<br>

### [[mutual exclusion|상호 배제]] (mutual exclution)
아래 그림은 세마포어를 이용하여 상호 배제를 구현한 프로세스들의 수행 과정   
☆ 세마포어를 이용하여 보호되는 공유 데이터를 접근하는 프로세스들의 수행 과정.
![[Pasted image 20240421232630.png]]   

<br>

## 생산자 소비자 문제
데이터를 만드는 생산자. 레코드나 문자들을 생성하고, 이것을 버퍼에 저장한다.
데이터를 사용하는 소비자. 소비자는 한 번에 하나씩 버퍼에서 데이터를 꺼내 소비한다.
=> 문제의 요구 조건 : 중첩이 되어선 안 됨. 즉, 생산자나 소비자 프로세스들 중에서 **하나만 한 시점에 버퍼에 접근할 수 있도록 제어**해줘야 함. 또한, 버퍼가 가득 차면 생산자는 더 이상 버퍼에 추가할 수 없고, 비어있으면 소비자가 꺼내갈 수 없도록 제어해야 한다.   
	저장되는 위치는 in 인덱스가 가리키는 곳, 저장 후 in 증가
	꺼내는 위치는 out 인덱스가 가리키는 곳, 꺼낸 후 out 증가
	**=> in > out을 확인해줘야 함.**


### 무한 버퍼에서 이진 세마포어를 이용한 생산자 소비자 문제 솔루션
```
// 생산자 소비자 프로그램
int n; // 세마포어, 버퍼에 존재하는 유효한 데이터의 개
binary_semaphore s = 1, delay = 0;
void producer()
{
	while (true) {
		produce();
		semWait(s);
		append();
		n++;
		if (n==1) semSignalB(delay);
		semSignalB(s);
	}
}

void consumer()
{
	int m; // 로컬 변수 , 소비자의 임계 영역 내에 보조 변수를 사용함.
	semWaitB(delay);
	while (true) {
	semWaitB(s);
	take();
	n--;
	m = n;
	semSignalB(s);
	consume();
	if (m==0) semWaitB(delay);
	}
}

void main()
{
	n = 0;
	parbegin (producer, consumer);
}
```
<br>

### ☆ 유한 버퍼(bounded buffer)에서 범용 세마포어를 이용한 생산자 소비자 문제 솔루션
semWait와 semSignal 연산은 반드시 [[atomic operation|원자적 연산]]으로 구현되어야 한다.
상호 배제이기 때문에, 한 시점에 오직 하나의 프로세스 만이 세마포어 변수를 접근할 수 있어야 한다. 
```
const int sizeofbuffer = // 버퍼사이즈
semaphore s = 1, n= 0, e = sizeofbuffer; // => 세마포어 도입
// s = 뮤텍스 세마포어로, 버퍼에 대한 상호 배제를 보장.
// n = 버퍼 내 아이템의 수를 추적하는 세마포어. 초기값 0. 소비자는 이 값이 0 보다 클 때만 데이터 소비 가능.
// e = 버퍼에서 빈 공간 수를 나타내는 세마포어. 초기 값은 sizeofbuffer. 생산자는 이 값이 0보다 클 때만 데이터를 버퍼에 추가 가능.

void producer()
{
	while (ture){
		produce(); // 데이터 생성.
		semWait(e); // 빈 슬롯이 있을 경우만 진행.
		semWait(s); // 버퍼에 접근하기 전 뮤텍스 세마포어를 사용하여 상호 배제 보장
		append(); // 실제로 버퍼에 데이터 추가.
		semSignal(s); // 버퍼 접근이 완료되면 뮤텍스 세마포어 해제.
		semSignal(n); // 소비자가 소비할 수 있는 데이터 항목 수를 증가시킴.
	}
}

void consumer()
{
	while (ture){
		semWait(n); // 소비할 데이터가 있는지 확인. 데이터가 없다면 여기서 대기.
		semWait(s); // 버퍼에 접근하기 전 뮤텍스 세마포어로 상호 배제 보장.
		take();  // 버퍼에서 데이터를 가져옴.
		semSignal(s);  // 버퍼 접근이 완료 되면 뮤텍스 세마포어 해제.
		semSignal(e); // 빈 슬롯의 수를 증가시켜, 생산자가 새로운 데이터를 추가할 수 있는 공간 생성.
		consume(); // 가져온 데이터를 소비하는 작업 수행.
	}
}

void main()
{
	parbegin (producer, consumer);
}
```

