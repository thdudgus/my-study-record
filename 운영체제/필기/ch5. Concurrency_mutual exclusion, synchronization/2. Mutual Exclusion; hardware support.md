
![[Pasted image 20240421173759.png]]
t**estval(테스트하려는 값)과 ＊word(메모리 위치에 저장된 값)를 비교하여 두 값이 동일하면 ＊word는 newval로 변경된다.** testval과＊word이 다르다면 ＊word의 값은 그대로 유지된다.    
리턴값이 testval과 같다면 메모리 값(＊word)은 갱신된 상태이다. (swap이 된 상태)  
<br>

### 하드웨어 기법을 이용한 상호 배제
☆ Compare & Swap 명령어
공유 변수는 0으로 초기화 되고, [[critical section|임계 영역]]에 진입할 수 있는 유일한 프로세스는 이 변수가 0일 때, Compare & Swap 명령을 호출한 프로세스이다.   
```
/* program mutualexclusion */
const int n = // 프로세스 개수
int bolt; // 공유 변수
void P(int i)
{
	while (true){
		while (compare_and_swap(bolt, 0, 1) ==1)  // 임계영역에 이미 프로세스가 존재하고 있을 때, 임계영역에 진입하려는 다른 프로세스는 대기하게 된다.(=busy waiting), bolt가 0이면 진입하고 1로 bolt값을 바꿈.
			// 대기
		// 임계영역
		bolt =0;  // 임계영역에 있었던 프로세스가 작업을 마치고 임계 영역을 나올 때 bolt의 값이 0으로 바뀌게 됨. 이 때 대기하던 프로세스들 중에서 오직 하나의 프로세스가 임계 영역에 진입.(그 프로세스는 Compare & Swap 명령을 먼저한 프로세스)
		임계영역 이후 코드
	}
}

void main ()
{
	bolt = 0;
	parbegin (P(1), P(2), ..., P(n) )
}
```
이 예제에서 **bolt가 0**이라는 의미 : **임계 영역에 프로세스가 존재하지 않음**   
<br>
Exchange 명령어
레지스터 값과 메모리에 들어있던 값을 서로 교체하는 기능.   
공유 변수 bolt는 0으로 초기화되고, 각 프로세스는 key라는 지역변수를 사용하며, 이 변수는 1로 초기화된다. 
```
/* program mutualexclusion */
const int n = // 프로세스 개수
int bolt; // 공유 변수
void P(int i) 
{
	int keyi = 1;
	while (true) {
		do exchange (keyi, bolt) // 임계영역으로 진입할 수 있는 프로세스는 bolt가 0일 때 exchange 명령어를 수행한 프로세스이다. 이 프로세스는 다른 프로세스의 징비을 막기 위해 bolt를 1로 설정하고 나갈 대 다시 bolt를 0으로 설정한다. 
		while (keyi != 0);  // 0이면 나옴.
	// 임계 영역
	bolt = 0;
	// 임계 영역 이후 코드
	}
}

void main ()
{
	bolt = 0;
	parbegin (P(1), P(2), ..., P(n) )
}
```
<br>
### 특별한 기계 명령어
**장점**
- 단일 processor 또는 메인 메모리를 공유하는 multiple processor에 모든 프로세스의 수를 적용 가능.
- 간단하고 쉽게 확인 가능
- 여러 임계 섹션을 지원하는 데 사용 가능. 각 임계 영역은 그 각각의 변수로 정의될 수 있음.   

**☆ 단점**
- busy-waiting를 사용한다. 따라서 프로세스가 임계 영역 접근을 기다리는 동안 프로세스는 processor를 계속 사용하고 있어야 한다.
- [[starvation|기아]]가 발생할 수 있다. 프로세스가 임계 영역을 나왔거나 대기하고 있던 프로세스가 여러개라면 발생 가능. (그 중 하나의 프로세스만이 다시 임계 영역 진입 가능.)
- [[deadlock|교착 상태]]에 빠질 수 있다. 
	프로세스 P1은 Compare & Swap(특별한 명령어)를 수행한 후, 임계 영역에 들어간다. 이때 P1보다 높은 우선순위의 P2가  생성되었고, 운영체제가 P2를 스케줄한다. 만약 P2가 P1과 같은 자원을 쓰려고 시도한다면, [[mutual exclusion|상호 배제]] 조건에 의해 P1의 접근이 실패하고 busy-wating을 수행한다. 그런데 P1은 다시 스케줄링 될 수 없다. P1보다 높은 우선순위의 P2가 계속 실행 상태(또는 실행 가능 상태)에 있기 때문.