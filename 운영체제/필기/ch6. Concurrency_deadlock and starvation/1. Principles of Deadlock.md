### ☆ [[deadlock|교착 상태]]
교착상태(deadlock)이란, 프로세스들의 집합이 더 이상 진행을 못 하고 영구적으로 블록되어 있는 상태.   

집합 내의 한 프로세스가 특정 사건의 발생을 기다리며 대기하고 있고, 이 사건이 집합 내의 다른 플록된 프로세스에 의해 발생될 수 있을 때, 이 프로세스 집합은 데드록 상태가 된다. 

교착 상태는 기다리던 사건이 발생하지 않기 때문에 영구적.    

효과적인 해결책이 없다.    
<br>
### 재사용 가능한 자원
프로세스가 사용하는 자원은 크게 2종류로 구분할 수 있다.
- **재사용 가능한 자원 (reusable)**
	프로세스의 사용에 의해 없어지지 않는 자원.
	따라서 프로세스가 사용한 후, 다른 프로세스가 다시 사용할 수 있도록 반납하게 된다. 
	e.g., processor, 입출력 채널, main memory, 보조 메모리, 장치, 파일이나 DB나 세마포어 같은 자료 구조 등
- **소모성 자원 (consumable)**
	생성되었다가 사용 이후 소멸되는 자원. 개수의 제한이 없음.
	블록되지 않은 생산 프로세스는 자원을 몇개라도 생성할 수 있다.
	자원이 소비 프로세스에 의해 사용되면 그 자원은 사라진다. 
	e.g., 인터럽트, 시그널, 메시지, 입출력 버퍼에 존재하는 정보 등
<br>
![[Pasted image 20240421232138.png]]  
각 프로세스는 디스트 상에 존재하는 파일D와 테이프 드라이브T를 사용하려 한다. 
위 그림은 프로세스의 수행 단계를 가상 코드로 기술한 것.    

교착 상태는 한 프로세스가 자원을 획득한 후 다른 자원을 원하며, 다른 프로세스는 반대 순서로 자원을 획득한 후 다른 자원을 원하면 발생한다.   
p0 → p1 → q0 → q1 → p2 → q2 라면 교착 상태가 발생.    

<br>
**☆ 메모리 요청 예시**
재사용 가능 자원에서의 교착 상태.   
![[Pasted image 20240421233057.png]]
현재 200Kbytes의 사용 메모리가 있는 상태에서 위 두 프로세스가 수행되는 상황.   

현재 가용 메모리가 200Kbytes이기 때문에 한 프로세스만 동작한다면 문제없이 수행될 수 있다.    

**하지만 P1이 첫번째 요청을 성공하고 P2도 첫번째 요청을 성공한 이후, 두번째 요청이 발생하면 두 프로세스 모두 블록된다.**
요청될 메모리의 양을 미리 모른다면, 시스템 설계상의 제한을 적용한다 하더라도 이 교착 상태를 해결하기 어렵다. 이 문제를 해결하는 최선의 방법은 가상 메모리를 사용하여 이 문제의 가능성을 없애는 것이다.   

<br>
### ☆ 운영체제 교착 상태 예방, 회피, 발견 기법 정리

| 접근 방법 | 자원 할당 정책                                      | 구체적인 기법                           | 장점                                                           | 단점                                                                        |
| ----- | --------------------------------------------- | --------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------------------- |
| 예방    | 보수적 <br/>(자원 할당이 가능하더라도 조건에 따라 할당하지 않을 수 있다.) | 모든 자원을 한꺼번에 요구                    | · 순간적으로 많은 일을 하는 프로세스에게 적합<br/>· 선점이 불필요                     | · 효율이 나쁨.<br/>· 프로세스 시작을 지연시킬 가능성 있음.<br/>·.프로세스는 사용할 모든 자원을 미리 알고 있어야 함. |
|       |                                               | 선점                                | 자원 상태의 저장과 복구가 간단한 자원에는 적용하기 쉬움                              | 선점이 필요보다 자주 일어남.                                                          |
|       |                                               | resource ordering                 | · 컴파일 시점에 강제할 수 있음.<br/>· 시스템의 설계 시점에 문제를 해결했기 때문에 동적 부하 없음. | 점진적인 자원 할당이 안 됨.                                                          |
| 회피    | 예방과 발견의 중간                                    | 교착 상태가 발생하지 않는 안전한 경로를 최소한 하나는 유지 | 선점이 불필요                                                      | · 운영체제는 자원에 대한 미래 요구량을 미리 알고 있어야 함.<br/>· 오랜기간 지연 발생의 가능성 있음.             |
| 발견    | 적극적 <br/>(자원 할당이 가능하면 즉시 할당)                  | 주기적으로 교착상태 발생 여부 파악               | · 프로세스 시작을 지연시키지 않음. <br/>· 온라인 처리 가능                        | 선점에 의한 손실 발생                                                              |
<br>
### ☆ 자원 할당 그래프
![[Pasted image 20240422001206.png]]
자원은 사각형
프로세스는 원

자원을 나타내는 사각형 노드 내부에 점은 그 자원의 instance.   

c는 교착상태. P1은 Rb를 할당 받아 사용하고 있고 Ra를 요청하고 있다.   
그런데 Ra는 P2에게 할당되었으며, P2는 Rb를 요청하고 있다. 

d는 c와 동일한 구조이지만, 자원의 instance가 여러 개이며, 교착상태는 아니다.    
<br>
### ☆ 교착 상태 조건
- **상호 배제** : 한 순간에 한 프로세스만이 자원을 사용할 수 있다.
- **점유 대기** : 이미 자원을 보유한 프로세스가 다른 자원을 요청하며 기다리고 있다.
- **비선점** : 프로세스에 의해 점유된 자원을 다른 프로세스가 강제적으로 빼앗을 수 없다.
위 세 가지가 기본적으로 필요하다. 

아래는 위 세 가지의 결과에 의해 발생한다. 즉, 위 경우의 복잡한 상호작용의 결과 해결할 수 없는 환형 대기 상태가 발생하게 되는 것. 
- **환형 대기** : 프로세스들 간에 닫힌 연결이 존재한다. 즉, 자원 할당 그래프에서 환형이 만들어지는 것(6.5c같은 그래프)
<br>
### ☆ Dealing with Deadlock
- 예방 (prevent) : 조건 중 하나를 시스템에서 허용하지 않는 것.
- 회피 (avoid) : 현재 자원 할당의 상태에 따라 안전하게 자원의 할당을 결정하는 것.
- 발견 (detect) : 데드록이 발생하면 그것을 발견하고 회복하는 것.