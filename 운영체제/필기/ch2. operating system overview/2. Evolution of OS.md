earliest computer들은 디스플레이 발광체, toggle, switch, input device, 그리고 프린터로 구성된 console로 동작했다.    
	문제점 
		- scheduling (스케줄링) : 할당된 시간보다 작업이 일찍 끝나면 그 만큼의 낭비 발생, 또는 할당된 시간 내에 작업이 완료되지 않아도 작업을 끝내야 함.
		- setup time : 작업이라 부르는 단일 프로그램들이 수행되기 위한 각 단계마다 mount, dismount, card deck 등이 준비돼있어야 하는데, 이 때 에러가 발생하면 사용자는 위 절차를 처음부터 다시 수행해야 하기 때문에, setup time에 상당한 시간이 걸리게 된다.   

이와 같이 사용자가 컴퓨터를 순차적으로 접근하기 때문에, 이러한 형태의 처리를 **Serial Processing (순차 처리)** 라고 한다.  

### Simple Batch System (단순 일괄 처리 시스템)   
monitor 소프트웨어 사용 -> 작업 처리 단계별로 컴퓨터에게 직접 명령을 내릴 필요가 없게 되었음.    
**Monitor**
job을 카드나 테이프에 담아 컴퓨터 operator에 제출하고 operator는 job들을 순서대로 한데 모아 모니터가 처리할 수 있도록 전체 작업묶음(batch)을 입력 장치에 넣는다.   
각 프로그램의 실행이 완료되면 제어가 모니터로 넘어가게 함으로써 모니터가 그 시점에서 다음 프로그램을 적재할 수 있다.

모니터 관점 : 모니터는 일련의 event들을 제어해야 하기 때문에 대부분이 항상 수행 가능한 상태로 memory에 적재되어 있어야 한다. -> 상주 모니터(resident monitor)   
모니터가 하나의 job을 사용자 프로그램 영역에 읽어 들이면, 제어가 그 job으로 넘어간다. job이 완료되면 제어는 다시 모니터로 남어가고 모니터는 즉시 다음 job을 읽어들인다. 각 작업의 결과는 프린터 같은 장치로 출력되어 사용자에게 전달된다.    

processor 관점 : processor는 모니터를 포함하는 메모리에서의 instruction을 수행한다. 
프로그램이 종료되거나 에러 조건이 발생할 때까지 사용자 프로그램 내의 instruction을 수행한다.    
job으로의 control 이동이란 말은 processor가 이제 사용자 프로그램 내의 instruction을 수행하기 시작했음 의미하며, monitor로의 control 복귀란 말은 processor가 이제 모니터 프로그램 내의 instruction을 수행하기 시작했음을 의미한다.   


각 작업 내에는 기본 형태의 작업 제어 언어(JCL : Job control Languages) instruction이 포함되어 있다. 이것은 특수한 형태의 프로그래밍 언어로, 모니터에 대한 instruction을 전달하는 데 사용된다.   


**필요한 하드웨어 기능**   
- memory protection : 수행 중인 사용자 프로그램은 monitor를 포함하고 있는 메모리 영역을 변경해선 안 된다.   
- timer : 단일 작업이 시스템을 독점하지 못 하도록 함. 타이머 값은 각 작업이 시작할 때 설정되고, 설정된 시간이 경과하면 제어는 monitor로 돌아간다.   
- previleged instruction : monitor만이 수행할 수 있는 명령어. 
- interrupts : flexible하게 사용자 프로그램과 제어를 주고받을 수 있다.   
<br>
메모리 보호와 특권 명령어의 도입은 동작 모드라는 개념을 가능하게 한다. 사용자 프로그램은 user mode에서 수행된다.
	user mode에선 사용자는 memory 특정 영역을 사용하지 못 하며, previleged instruction를 수행할 수 없다.    
monitor(모니터)는 system mode, 혹은 kernel mode라고 불리는 모드에서 수행된다.
	kernel mode에선 previleged instruction이 수행될 수 있고, 보호 메모리 영역도 접근 가능하다.   
<br>
### Multipogrammed Batch System (멀티프로그래밍 일괄 처리 시스템)   
main memory의 크기는 운영체제(상주 모니터)와 하나의 사용자 프로그램이 적재될 수 있도록 충분해야 한다.    
한 작업이 입출력 완료를 대기해야 할 때 processor는 입출력을 대기할 것 같지 않은 다른 작업으로 제어를 넘긴다. 더 나아가 운영체제와 여러 개의 프로그램이 상주할 수 있는 공간이 있다면, processor는 이 프로그램들이 입출력 대기에 들어간 틈을 이용해 돌아가며 실행시킬 수 있다.   
![[Pasted image 20240420221904.png]]   

<br>
### ☆[[Process]]   
- 수행 중인 프로그램
- 컴퓨터 상에서 수행 중인 프로그램의 instance
- processor에 할당되어 수행될 수 있는 entity
- 단일 순차 실행 thread, 현재 상태, 연계된 시스템 자원 등에 의해 특징 지어지는 활동 단위.    
<br>
☆**에러의 원인**   
-  부적절한 synchronization : 프로그램은 데이터가 버퍼에서 사용할 수 있을 때까지 대기해야 한다. 이러한 경우 읽기가 완료되었음을 알리는 신호가 보류 중인 프로그램으로 전달 되어야 한다. 신호 전달 기법을 잘못 설계하면 신호가 분실되거나 중복 전달 될 수 있다.   
- mutual exclusion 실패 : 다수의 사용자 또는 프로그램이 공유 자원의 사용을 시도하는 경우가 종종 있다. 어느 한 순간에는 오직 하나의 프로그램만이 파일에 대해 갱신을 수행할 수 있도록 하는 mutual exclusion기법이 반드시 필요하다.    
- nondeterminate program operation : 특정 프로그램의 결과는 정상적인 경우 그 프로그램의 입력에 의해서만 결정되어야 하며, 공유 시스템 내의 다른 프로그램의 수행 상태에 다라 달라져서는 안 된다. 그러나 메모리를 공유하는 프로그램들을 processor가 interleaving 방식으로 실행시킬 때, 동일한 공유 메모리 영역에 예측 불가능한 방식으로 overwrite함으로써 프로그램의 수행을 서로 방해할 수 있다. 따라서 서로 다른 프로그램들의 실행 순서가 특정 프로그램의 수행 결과에 영향을 미칠 수 있다.
- 교착상태 (deadlock) : 두 개 이상의 프로그램이 서로 상대방 프로그램에 할당된 자원의 release를 기다리면서 대기할 때가 있다. 이러한 교착상태는 자원이 어떤 순서로 할당되고 회수되느냐에 따라 발생할 수도 있고 아닐 수도 있다.    
<br>
**☆프로세스의 component**
- 수행 가능한 프로그램
- 프로그램이 필요로하는 연관된 데이터(변수, work space, buffers, 등)
- 프로그램의 context (or process state)의 수행 : is essential
	OS가 프로세스를 감독하고 제어할 수 있는 내부 데이터.   
	다양한 프로세스 레지스터를 포함.    
	프로세스의 우선순위 및 프로세스가 특정 I/O event 완료를 기다리고 있는지 여부와 같은 정보를 포함.
<br>
**☆프로세스 관리**   
- 프로세스의 전체 상태는 언제든지 context에 포함된다.    
- 기능을 지원하는 데 필요한 모든 새로운 정보를 포함하도록 context를 확장하여 새로운 기능을 설계하고 OS에 통합할 수 있다.    
![[Pasted image 20240421000747.png]]   
<br>
**☆메모리 관리**  
운영체제는 다섯 개의 주요 저장공간 관리 책임을 가진다.    
1. 프로세스 isolation
2. 자동 할당과 관리
3. modular programming 지원
4. 보호와 접근 제어
5. long-term storage

