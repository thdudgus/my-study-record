
> 참고하면 좋은 링크
> https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4
<br>
### ☆ [[Process|프로세스]]의 특성
1. **resource 소유권**
	**프로세스는 자신의 [[process images|프로세스 이미지]]를 위한 virtual memory 공간을 포함한다.** 
	때때로 주기억장치, 입출력 채널, 입출력 장치, 그리고 파일과 같은 resource에 대한 제어와 소유권을 프로세스에 할당할 수 있다. 운영체제는 보호 기능을 수행하여 프로세스들 간에 자원에 대한 불필요한 간섭이 일어나는 것을 막는다.   
2. **스케줄링/수행**
	**프로세스 수행은 하나 이상의 프로그램을 통과하는 수행 경로를 따른다. 한 프로세스는 다른 프로세스들과 번걸아가면서(interleave) 수행될 수 있다.** 
	따라서 프로세스는 수행 상태와 디스패칭([[dispatch|dispatching]]) 우선순위를 가지며, 운영체제에 의해 스케줄 되고 디스패치 되는 개체이다.   

위 두가지 특성은 서로 독립적. 
운영체제 의해서 독립적으로 취급될 수 있음.    

위 두가지 특성을 구별하기 위해 디스패칭 단위는 [[thread]] 또는 경량 프로세스([[lightweight preocess]]), 
resource 소유권 단위는 [[Process|프로세스]] 또는 테스크([[task]])라고 한다.   
<br>
### [[MultiThreading]]
하나의 프로세스 내에서 수행되는 여러 개의 [[thread]]를 지원하는 기능.
<br>
### ☆ 프로세스 내 하나 이상의 Thread
각 thread는 아래의 것들을 갖는다.
- an execution state (Runnig, Ready, etc,.)
- running이 아닐 때, 저장된 thread context 
- an execution stack
- 로컬 변수에 대한 thread 단위의 static storage
<br>
### ☆ Threads vs Processes (in 프로세스 관리의 관점)
![[Pasted image 20240421052546.png]]

1. **단일 스레드 프로세스 모델**:
    - 프로세스는 **프로세스 제어 블록(PCB), 사용자 주소 공간**, 사용자 스택, 커널 스택 등을 포함.
	    사용자 스택은 함수 호출과 복귀를 관리하는 데 사용됨.
    - 한 프로세스가 수행되는 동안, 이 프로세스는 processor register를 제어. 
	    프로세스가 수행 중이지 않을 때, processor register의 내용은 저장됨.
    
2. **멀티 스레드 프로세스 모델:
    - (공통점)멀티 스레드 환경에서도 프로세스는 **단일 제어 블록(PCB)과 사용자 주소 공간**을 공유.
    - (차이점)단일 스레드 프로세스 모델과 달리, 각 스레드는 별도의 사용자 스택을 가지며, 스레드별 제어 정보(레지스터 값, 우선순위 등)를 포함하는 자체 제어 블록을 가짐.
    - 프로세스 내의 모든 스레드는 동일한 자원(메모리, 파일 등)을 공유합니다.

=> 프로세스 내의 **모든 thread들은 그 프로세스의 상태와 resource를 공유**한다. 
그 thread들은 같은 주소 공간에 존재하며, 동일한 데이터를 접근한다. 
프로세스 내의 한 thread가 메모리에 있는 데이터 항목을 변경했을 경우, 다른 thread도 그 데이터 항목에 접근하여 그 결과를 확인할 수 있다. 
	만일, 하나의 쓰레드가 읽기 권한을 가지고 파일을 개방하면, 같은 프로세스에 있는 다른 thread들도 그 파일을 읽을 수 있다. 
	
![[Pasted image 20240421045613.png]]

<br>
### Thread의 장점
- 새로운 프로세스를 생성하는 시간보다 기존 프로세스 내에서 새로운 스레드를 생성하는 시간이 더 짧다.
- 프로세스 종료 시간보다 스레드 종료시간이 짧다.
- 프로세스들 간 교환보다 같은 프로세스에 있는 두 스레드 간 교환이 효율적.
- 서로 다른 수행 프로그램들 간 통신에서 효율적. (같은 프로세스 내의 스레드들은 메모리 및 파일을 공유하기 때문에, 커널을 호출하지 않고도 서로 통신 가능.)
<br>
### 단일 사용자의 Thread 사용
- foreground와 background 작업
- asynchronous(비동기) processing(처리)
- 빠른 execution
- modular program structure