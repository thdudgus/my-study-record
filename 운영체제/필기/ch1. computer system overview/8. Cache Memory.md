- OS에 보이지 않음.   
- 다른 memory management hardware와 interaction
- processor는 instruction cycle마다 한 번 이상 memory access를 해야한다.    
- memory cycle 시간에 따라 processor 시간이 제한된다.   
- 작고 빠른 memory로 [[Locality of reference]](principle of locality)를 활용한다.   
<br>
## cache memory의 목적   

이용 가능한 가장 빠른 메모리의 속도에 근접한 메모리를 제공하는 동시에, 비용이 저렴한 대용량의 메모리를 제공하는 것. 
![[Pasted image 20240402083346.png]] 
비교적 대용량이고 속도가 느린 main memory가 소용량이지만 속도가 빠른 cache와 함께 사용된다.   
cache는 main memory 일부의 복사본을 포함하고 있다.    
processor가 메모리에서 한 word를 읽으려 할 때, 그 word가 cache 내에 있는지 여부를 점검해야 한다. 있으면 그 word는 바로 processor로 전달되고, 그렇지 않으면 고정된 개수의 word로 구성된 main memory block이 cache로 읽혀진 뒤 해당 word가 processor로 전달된다.   
[[Locality of reference]] 때문에, 어떤 메모리의 참조를 위해 하나의 데이터 block을 캐시로 가져오게 되면, 그 이후의 참조는 그 block 내에 있는 word일 확률이 높다.
<br>
![[Pasted image 20240402084729.png]] 
속도 L1 cache > L2 cache > L3 cache   
용량  L3 cache > L2 cache > L1 cache   
<br> 
**cache, main memory 구조**
![[Pasted image 20240402085205.png]] 
**main memory**
	- 2^n개의 주소지정 가능 word, 각 word엔 각기 다른 n비트 주소 부여.    
	- mapping을 위해 k개의 word로 이루어진 고정 길이 block들로 구성된다.   
	- M=2^n개의 block들로 구성.   
**cache**   
	- K개의 word로 이루어진 C 개의 slot.
	- slot의 개수는 main memory block의 개수보다 훨씬 적음. (C<<M), main memory의 일부는 cache slot에 저장됨.   
	- if cache에 없는 memory block 내의 한 word를 읽게 되면, 그 block은 cache의 slot 중 하나로 전달된다. slot 보다 block의 개수가 많기 때문에 각 slot이 특정 block에 영구적으로 할당될 수 없다. 따라서 각 slot은 현재 어떤 block을 load하고 있는지를 나타내는[[ tag]]를 포함한다.   
<br>
## cache의 읽기 연산   

![[Pasted image 20240402090537.png]]
processor는 읽을 word의 주소 RA를 생성.   
만약 주소가 cache에 포함되어 있으면 바로 processor로 전달.   
그렇지 않으면, 그 word를 포함하고 있는 block이 먼저 cache로 load되고, 해당 word가 processor로 전달.   
<br>
## Cache design   
- cache size : 비교적 적은 용량의 cache가 성능에 큰 영향을 끼칠 수 있음.   
- block size : cache와 main memory 간에 교환되는 데이터 단위.   
- mapping function : 새로운 data block이 cache로 읽혀질 때, 그 block이 cache의 어느 위치에 저장될지 결정.   
- replacement algorithm : 모든 cache slot이 채워져 있어 새로운 block을 load할 slot이 없을 때, mapping function의 constraint가 만족하는 범위 내에서 교체할 block을 선정한다.   
<br>
## Write Policy   
만약 cache 내에 있는 어떤 block의 내용이 변경되었으면, 교체하기 전에 그것에 해당하는 main memory의 내용을 update해야 한다.   
write policy는 memory write operation을 언제 수행할지 결정한다.   
수행 경우
- block이 update될 때마다   
- block이 replace될 때마다   
	write operation을 최소화하거나 main memory가 최신 자료가 아닌 이미 쓸모 없어진(obsolete) 자료를 저장하고 있게 된다.   
	

