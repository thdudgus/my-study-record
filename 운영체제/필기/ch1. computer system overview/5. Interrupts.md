가상적으로 모든 컴퓨터는 processor의 일반적인 처리에 다른 모듈들(I/O, memory)이 interrupt를 걸 수 있도록 허용하고 있다.   
interrupt는 기본적으로 procesor의 처리율을 향상시키기 위해 제공된다.   
	대부분의 I/O device들은 processor보다 느리다. 따라서 processor는 device를 기다려야 한다. = wasteful use of processor   
<br>
**interrupt = 예상치 못한, 외부에서 발생한 이벤트**   

<br>

**☆ classes of interrupts**
![[Pasted image 20240402034900.png]]   
I/O interrupt : e.g. 게임을 하고 있을 때 마우스 입력 (proessor는 언제 마우스 입력이 들어올지 알지 못 함.   

<br>

**interrupt가 있는 경우와 interrupt가 없는 경우의 프로그램 제어 흐름.**
![[Pasted image 20240402035219.png]]   
interrupt를 이용할 경우, 입출력 연산이 진행되는 동안 processor는 다른 instruction을 수행시킬 수 있다.   
사용자 프로그램은 실행 도중 사이사이에 일련의 WRITE를 호출한다. 수직 실선은 프로그램 코드의 segment이고, segment1, 2, 3은 입출력을 포함하지 않은 일련의 instructions.   
WRITE 호출은 시스템 utility인 입출력 루틴에 대한 것이고 실제 입출력 연산을 수행한다.   
**그림(b)**   
	WRITE 형태의 시스템을 호출하는 지점에서 사용자 프로그램이 도달했다고 가정. 이 경우 호출되는 입출력 프로그램은 준비 코드와 실제 입출력 명령으로 구성된다.   
	이러한 instruction들이 수행된 후 제어는 사용자 프로그램으로 리턴되고, 외부 장치는 컴퓨터 메모리로부터 데이터를 받아 인쇄하느라 바빠진다. 이러한 입출력 작업은 사용자 프로그램 내의 명령어 수행과 동시에 일어난다.    
	외부 장치가 다시 서비스할 준비가 되면, 즉 processor로부터 데이터를 더 바아들일 준비가 되면, 그 외부 장치의 입출력 모듈은 interrupt request 신호를 처리기로 보낸다. 이에 대한 반응으로, processor는 수행 중이던 프로그램의 작업을 보류하고 해당 입출력 장치를 서비스 하기 위한 루틴, 즉 interrupt processor라고 불리는 프로그램으로 분기하며, 장치에 대한 서비스 후 보류했던 프로그램의 수행을 재개한다. 
	![[Pasted image 20240402051637.png]]

☆ instruction cycle with interrupts
![[Pasted image 20240420232611.png]]


☆ 간단한 interrupts 처리
![[Pasted image 20240420232726.png]]


☆interrupt로 인한 메모리 변화 
![[Pasted image 20240420233021.png]]
이해가 조낸 안 돼요 히히히
인터럽트 관련 다시 하기

https://velog.io/@adam2/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8