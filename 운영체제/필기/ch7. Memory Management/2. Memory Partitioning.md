### ☆ 메모리 관리 기법
| **기술**        | **설명**                                                                                                                        | **강점**                                                    | **약점**                                                           |
| ------------- | ----------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------- | ---------------------------------------------------------------- |
| 고정 분할         | 시스템 생성 시에 주기억장치가 고정된 파티션들로 분할된다.<br/>프로세스는 균등사이즈의 파티션 도는 그보다 큰 파티션으로 적재된다.                                                    | 구현이 간단하다 : 운영체제에 오버헤드가 거의 없다.                             | 내부 단편화로 인한 비효율적인 사용.<br/>최대 활성 프로세스 수가 고정됨                       |
| 동적 분할         | 파티션들이 동적으로 생성되며, 각 프로세스는 자신의 크기와 일치하는 크기의 파티션에 적재된다.                                                                          | 내부단편화가 없고, 주기억장치를 보다 효율적으로 사용할 수 있다.                      | 외부 단편화를 해결하기 위한 메모리 집약(compaction)이 요구되기 때문에 processor 효율이 나빠진다. |
| 단순 페이징        | 주기억장치는 균등사이즈의 프레임으로 나뉜다.<br/>각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지들로 나뉜다.<br/>프로세스의 모든 페이지가 적재되어야 하며, 이 페이지를 저장하는 프레임들은 연속적일 필요는 없다. | 외부 단편화가 없다. 주 메모리를 효율적으로 사용한다.                            | 적은 양의 내부 단편화가 생긴다                                                |
| 단순 세그멘테이션     | 각 프로세스는 여러 세그먼트들로 나뉜다.<br/>프로세스의 모든 세그먼트가 적재되어야 하며, 이 세그먼트를 저장하는 동적 파티션들은 연속적일 필요는 없다.                                        | 내부 단편화가 없고, 메모리 사용 효율이 개선되며, 동적분할에 비해서 오버헤드가 적다           | 외부 단편화                                                           |
| 가상 메모리 페이징    | 단순 페이징과 비교해서, 프로세스의 페이지 전부를 로드시킬 필요가 없다. <br/>필요한 페이지가 있으면 후에 자동적으로 불려들어진다.                                                   | 외부 단편화가 없다.<br/>멀티 프로그래밍 정도가 높으며, 가상 주소 공간이 크다.           | 복잡한 메모리 관리의 오버헤드                                                 |
| 가상 메모리 세그멘테이션 | 단순 세그멘테이션과 비교해서 필요하지 않는 세그먼트들을 로드하지 않는다.<br/>필요한 세그먼트가 있으면 나중에 자동으로 불려들어진다.                                                   | 내부 단편화가 없다.<br/>높은 수준의 멀티프로그래밍, 큰 가상 주소 공간, 보호와 공유를 지원한다. | 복잡한 메모리 관리의 오버헤드                                                 |


### 동적 분할
파티션의 크기와 개수는 가변적.   
한 프로세스가 주기억장치로 적재될 때 정확히 요구된 크기만큼의 메모리만 할당 받는다.   

**External Fragmentation**
- 메모리는 점점 더 fragmented
- 메모리 사용률 저하

**Compaction**
- External Fragmentation을 극복하기 위한 기술
- 연속성을 유지하도록 OS가 파티션을 이동시킴
- 빈 공간이 하나의 블록이 되도록 함. 
- 시간  소모 및 CPU time 낭비하는 단점이 있음.
<br>
### 배치 알고리즘
프로세스를 주기억장치로 적재하거나 스왑인 하려고 할 때 충분한 크기의 사용 가능한 메모리 블록이 두 개 이상 있다면 운영체제는 어떤 블록에 할당할 것인지를 결정해야만 한다.   
**최적 적합 (best-fit)** : 요청된 크기와 가장 근접한 크기의 메모리 선택
**최조 적합 (firts-fit)** :  메모리의 처음부터 검사해서 크기가 충분한 첫 번째 사용 가능한 메모리 블록을 선택
**순환 적합 (next-fit)** : 가장 최근에 배치되었던 메모리의 위치에서부터 검사를 시작해 크기가 충분한 다음 위치의 사용 가능한 메모리 블록을 선택

**☆ memory configuration example**   
![[Pasted image 20240422025438.png]]   
몇 번의 배치와 스왑아웃 연산 후에 메모리 구성을 보여주고 있음.   

a에선 마지막으로 사용되었던 블록은 22MB이었는데, 그 블록에서 14MB 파티션이 만들어졌다.    
b에선 16MB의 할당 요구에 대한 최적 적합과 최초 적합 그리고 순환 적합 사이의 차이를 보여주고 있다. 최적 적합은 사용 가능한 모든 블록들을 조사 후 18MB짜리 블록을 사용하여 2MB의 단편을 담기게 된다. 최초 적합은 6MB, 순환 적합은 20MB의 단편을 담겼다.   

=> 일반적인 분석 : **최초 적합 알고리즘은 가장 간단할 뿐만 아니라 대부분의 경우 최적**이며, 또한 가장 빠르다. (최적은 이름과 다르게 가장 성능이 나쁘다. 가장 작은 단편을 만들어낸다. 메모리 집약 작업이 다른 알고리즘들보다 더욱 자주 수행되어야 함.)

