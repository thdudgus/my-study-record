### Table of Contents
1. [[#[자료형과 변수]|[자료형과 변수]]]
	1. [[#[자료형과 변수]#자료형|자료형]]
2. [[#[메소드]|[메소드]]]
	2. [[#[메소드]#메소드|메소드]]
	3. [[#[메소드]#변수의 범위|변수의 범위]]
3. [[#[클래스]|[클래스]]]
	4. [[#[클래스]#클래스|클래스]]
	5. [[#[클래스]#This|This]]
	6. [[#[클래스]#생성자|생성자]]
	7. [[#[클래스]#Getter와 Setter|Getter와 Setter]]
	8. [[#[클래스]#접근 제어자|접근 제어자]]
	9. [[#[클래스]#패키지|패키지]]
	10. [[#[클래스]#상속|상속]]
	11. [[#[클래스]#[[Polymorphism|다형성]]|[[Polymorphism|다형성]]]]
	12. [[#[클래스]#Super|Super]]
	13. [[#[클래스]#Final|Final]]
4. [[#[추상 클래스와 인터페이스]|[추상 클래스와 인터페이스]]]
	14. [[#[추상 클래스와 인터페이스]#추상 클래스|추상 클래스]]
	15. [[#[추상 클래스와 인터페이스]#인터페이스|인터페이스]]
5. [[#[제네릭스]|[제네릭스]]]
	16. [[#[제네릭스]#제네릭스|제네릭스]]
	17. [[#[제네릭스]#[제네릭 클래스]|[제네릭 클래스]]]
	18. [[#[제네릭스]#Wrapper 클래스|Wrapper 클래스]]
	19. [[#[제네릭스]#ArrayList|ArrayList]]
	20. [[#[제네릭스]#LinkedList|LinkedList]]
	21. [[#[제네릭스]#HashSet|HashSet]]
	22. [[#[제네릭스]#HashMap|HashMap]]
	23. [[#[제네릭스]#Iterator|Iterator]]
6. [[#[익명클래스, 람다와 스트림]|[익명클래스, 람다와 스트림]]]
	24. [[#[익명클래스, 람다와 스트림]#익명 클래스|익명 클래스]]
	25. [[#[익명클래스, 람다와 스트림]#람다식|람다식]]
	26. [[#[익명클래스, 람다와 스트림]#함수형 인터페이스|함수형 인터페이스]]
	27. [[#[익명클래스, 람다와 스트림]#스트림|스트림]]
7. [[#[예외처리]|[예외처리]]]
	28. [[#[예외처리]#예외 발생시키키|예외 발생시키키]]
	29. [[#[예외처리]#Try With Resource|Try With Resource]]
	30. [[#[예외처리]#사용자 정의 예외|사용자 정의 예외]]
	31. [[#[예외처리]#예외 처리 미루기|예외 처리 미루기]]
8. [[#[쓰레드]|[쓰레드]]]
	32. [[#[쓰레드]#Thread|Thread]]
	33. [[#[쓰레드]#Join|Join]]
	34. [[#[쓰레드]#다중 쓰레드|다중 쓰레드]]
	35. [[#[쓰레드]#Runnable|Runnable]]


---
----


# [자료형과 변수]
## 자료형
- 기본 자료형
	- 실제 데이터 값을 저장
	- int, long, double, boolean, char, ....
- **참조 자료형**
	- 데이터가 저장된 메모리 주소 값을 저장
	- class, interface, array, enum, **String**, ....

기본 자료형은 `a = b`를 하면 값이 복사되는 반면, 참조 자료형은 `a = b`를 하게 되면 a의 참조가 b를 향하게 된다. (즉, a, b가 같은 걸 참조하게 되는 것.)

#### 문자열 기능
![[스크린샷 2025-05-14 오후 11.09.31.png]]
![[스크린샷 2025-05-14 오후 11.12.26.png]]s.sunstring(7)은 7번째부터만 남게 됨.

#### 문자열 비교
```java
// s1과 s2가 같은 위치를 참조하여 true가 출력됨
String s1 = "Java";
String s2 = "Java";
System.out.println(s1==s2);

// s1과 s2가 다른 위치를 참조(새 String)하여 false가 출력됨
String s1 = new String("Java");
String s2 = new String("Java");
System.out.println(s1==s2);

// 따라서 문자열 구조를 아래와 같이 해야 함.
System.out.println(s1.equals(s2));
```

### 배열
```java
// <선언>
자료형[] 변수명 = new 자료형[크기];
// 또는
자료형 변수명[] = new 자료형[크기];
int[] numbers = new int[5];
String[] names = new String[3];

// <초기화>
numbers[0] = 1;
...

// <선언과 초기화를 한 번에>
int[] numbers = new int[] {1, 2, 3, 4, 5};
//또는
int[] numbers = {1, 2, 3, 4, 5};
```

#### 다차원 배열
```java
// 선언과 초기화
int[][] numbers = new int [2][5];
k = 1;
for (int i = 0; i<numbers.length; i++){
	for (int j = 0; j<numbers[i].length; j++){
		numbers[i][j] = k;
		k++;
	}
}
numbers[0][2] = 3;

// 선언과 초기화 한 번에
int[][] numbers = new int [][]  {
{1, 2, 3, 4, 5},
{6, 7, 8, 9, 10}
};
```

---

# [메소드]
## 메소드
```java
// 메소드 선언
접근제어자 반환형 메소드명(전달값){
	명령문 1;
	....
	return 반환값;
}

int result = print("Hello");
public static int print(String text) {
	System.out.println(text);
	return 100;
}
```
##### 메소드 오버로딩
같은 이름, 다른 매개변수
```java
public static int add(int a, int b){
	return a+b;
}

public static int add(int a, int b, int c){
	return a+b+c;
}

public static int add(double a, souble b){
	return a+b;
}

public static void main(String[] args) {
	System.out.println(add(1, 2));
	System.out.println(add(1, 2, 3));
	System.out.println(add(5.27, 3.13));
}
```

## 변수의 범위
변수가 선언된 영역 `{ }` 내에서만 사용 가능

---
# [클래스]
## 클래스
데이터와 기능을 포함하는 코드 묶음.

**객체:** 클래스를 통해 만들어진 것들
ex) 클래스 - **종이접기 책**
	객체 - 종이접기 책으로 만든 **종이 학들**

```java
// 클래스 선언
class Person {

}

// 객체 생성
public static void main(String[] args) {
	Person person - new Person();
}
```

#### 인스턴스 변수
클래스 내에 선언된 변수
```java
class Person {
	// 인스턴스 변수
	String name;
	int age;
}

public static void main(String[] args) {
	Person person - new Person();
	person.name = "철수";
	person.age = 20;
}
```
인스턴스 변수는 객체마다 서로 다른 값을 가질 수 있다.
객체를 만들어야 접근 가능.

#### 클래스 변수
클래스 내에 static으로 선언된 변수.
모든 객체가 공유하는 변수.
```java
class Person {
	String name;
	int age;
	// 클래스 변수
	static int personCount = 0;
}

public static void main(String[] args) {
	Person.personCount = 10;
	System.out.println(Person.personCount)
}
```
객체를 만들 필요 없이 클래스 명으로 접근 가능.

#### 인스턴스 메소드
클래스 내에 정의된 메소드
```java
class Person {
	String name;
	int age;
	static int personCount = 0;
	// 인스턴스 메소드 선언
	public void introduce() {
	System.out.println("이름: " + name)};
	System.out.println("나이: " + age)};
}

public static void main(String[] args) {
	Person person - new Person();
	person.name = "철수";
	person.age = 20;
	// 인스턴스 메소드 사용
	person.inroduce();
}
```

#### 클래스 메소드
클래스 내에 static으로 정의된 메소드
```java
class Person {
	String name;
	int age;
	static int personCount = 0;
	// 클래스 메소드 선언
	public static void introduce() {
	System.out.println("이름: " + name)};
	System.out.println("나이: " + age)};
}

public static void main(String[] args) {
	// 클래스 변수
	Person.personCount = 10;
	// 클래스 메소드 사용
	Person.inroduce();
}
```


## This
자기 자신 (인스턴스 / 지역 변수 구분)
```java
class Person {
	String name;
	public void setName(String name) {
		this.name = name;
		}
}
```
`this.name = name`의 `this.name`은 클래스의 인스턴스 변수인 name
`this.name = name`의 `name`(우변)은 전달 값으로 받은 name
**=> 전달 받은 값이 객체의 변수 값으로 할당되게 됨**


## 생성자
객체가 생성될 때 호출되는 메소드.
```java
class Person {
	String name;
	int age;
	// 초기화 작업
	Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
}
```
객체를 생성할 때 전달 받은 값으로 객체가 초기화 됨.


## Getter와 Setter
Getter: 인스턴스 값을 반환
Setter: 인스턴스 값을 설정
```java
class Person {
	String name;
	
	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
}

public static void main(String[] args) {
	Person person = new Person();
	person.setAge(20);  // 객체의 age 변수를 20으로 설정
	System.out.println(person.getAge()); // 객체의 age 변수값 가져오기   
}
```



## 접근 제어자
![[스크린샷 2025-05-15 오전 12.24.02.png]]


## 패키지
관련 클래스들을 그룹화 (폴더)
다른 패키지의 클래스를 사용할 때는 아래처럼 import해야 사용할 수 있다.
```java
// 한 패키지 안 한 클래스를 사용하는 경우
import 패키지명.클래스명;
// 한 패키지 안 여러 클래스를 사용하는 경우
import 패키지명.*

// java패키지 내, util 패키지 내 Random 클래스 사용
import java.util.Random;
public class MyClass {
	public static void main (String[] args){
		Random random = new Random();
		int num = random.nextInt();
	}
}
```


## 상속
특정 클래스의 기능을 재사용 및 확장
![[스크린샷 2025-05-15 오전 12.28.45.png|500]]
```java
class Student extends Person {
	String school;
}
```

### 메소드 오버라이딩
부모 클래스의 메소드 재정의.
```java
class Person {
	public void introduce() {
	System.out.println("사랍입니다.");
	}
}

class Student extends Person {
	public void introduce() {
	System.out.println("학생입니다.");
	}
}
```
Person 객체 생성 시, "사람입니다." 출력.
Student 객체 생성 시, "학생입니다." 출력.

=> **자식 클래스가 부모 클래스의 메소드를 덮어쓰는 것.**


## [[Polymorphism|다형성]]
여러 형태로 동작할 수 있는 성질
```java
class Person {
	public void introduce() {
	System.out.println("사랍입니다.");
	}
}
class Student extends Person {
	public void introduce() {
	System.out.println("학생입니다.");
	}
}

public static void main(String[] args) {
	Person person = new Person(); // Person을 참조하고 Person의 object이다.
	Person student = new Student();  // Person을 참조하지만 Student의 object이다. (type은 Person이지만, 가리키고 있는 instance는 Student)
	
	person.introduce(); // 사람입니다.
	student.introduce(); // 학생입니다.
}
```
바인딩은 runtime 때 이루어진다.


## Super
부모 클래스에 접근하기 위해 사용.
```java
class Person {
	int age;
	Person(int age) {
		this.age = age;
	}
}

class Student extends Person {
	String school;
	Student(int age, String school) {
		super(age); // this.age = age; 부모 클래스에 정의되어 있는 생성자 활용
		this.school = school;
	}
}
```


## Final
선언과 초기화 후, 변수값 재할당, 메소드 오버라이딩 불가.


---
# [추상 클래스와 인터페이스]
## 추상 클래스
```java
abstract class Shape {
	abstract double calculateArea();
}

class Square extends Shape {
	private double s;
	public Square(double s) {
		this.s = s;
	}
	double calculateArea() {
		return s*s;
	}
}
class Circle extends Shape {
	private double r;
	public Circle(double r) {
		this.r = r;
	}
	double calculateArea() {
		return Math.PI*r*r;
	}
}
```
Shape 클래스는 미완성이지만, 자식 클래스들이 미완성인 부분을 완성시킬 수 있음.


## 인터페이스
클래스를 작성할 때 기본이 되는 뼈대.
```java
interface Shape {
	double calculateArea();
}

class Square implements Shape {
	private double s;
	public Square(double s) {
		this.s = s;
	}
	double calculateArea() {
		return s*s;
	}
}
class Circle implements Shape {
	private double r;
	public Circle(double r) {
		this.r = r;
	}
	double calculateArea() {
		return Math.PI*r*r;
	}
}
```
인터페이스를 구현하는 클래스에선 반드시 인터페이스의 메소드들을 구현해야 한다. 

---

# [제네릭스]
## 제네릭스
다양한 형태의 데이터를 일반화하여 다룰 수 있게 해줌.
코드의 재사용성을 높이고, 타입 안정성 확보 가능
```java
public static <T> void printValue(T value) {
	System.out.println(value);
}
```

## [제네릭 클래스]
제네릭 기반 클래스. 
다양한 데이터 유형을 처리할 수 있는 클래스
```java
class Box<T> {
	T data;
	public void setData(T data) {
		this.data = data;
	}
}

public static void main(String[] args) {
	Box<Integer> iBox = new Box<>();
	iBox.setData(3);  // 정수 담기
	
	Box<String> iBox = new Box<>();
	iBox.setData("안녕");  // 문자열 담기
}
```


## Wrapper 클래스
기본 자료형을 객체로 감싸서 추가 기능을 제공하는 클래스
![[스크린샷 2025-05-15 오전 2.07.37.png|400]]
```java
public static void main(String[] args) {
	Integer i = 1;
	Double d = 1.0;
	Character c = 'a';
	
	System.out.println(i.intValue());
	System.out.println(d.intValue());  
	System.out.println(c.intValue());
```
Double이 wrapper 클래스이기 때문에 d를 int로 출력하는 기능을 사용할 수 있음.


## ArrayList
배열 기반 리스트 , 빠른 접근 + 순차 저장
```java
public static void main(String[] args) {
	ArrayList<String> list = new ArrayList<>();
	list.add("철수");
	list.add("영희");
	
	for (String s: list) {
		System.out.println(s);
	}
}
```
![[스크린샷 2025-05-15 오전 2.21.49.png]]


## LinkedList
연결 리스트, 데이터의 빠른 삽입 + 삭제
노드로 연결되어 있음.
```java
public static void main(String[] args) {
	LinkedList<String> list = new LinkedList<>();
	list.add("철수");
	list.add("영희");
	
	for (String s: list) {
		System.out.println(s);
	}
}
```
![[스크린샷 2025-05-15 오전 2.23.34.png]]


## HashSet
순서, 중복을 허용하지 않는 데이터 집합
```java
public static void main(String[] args) {
	HashSet<String> set = new HashSet<>();
	set.add("철수");
	set.add("영희");
	set.add("철수");  // 이미 철수가 있어서 추가 안 함
}
```
![[스크린샷 2025-05-15 오전 2.25.11.png]]


## HashMap
(key, value)의 자료구조로, 중복과 순서를 허용하지 않는 컬렉션
```java
public static void main(String[] args) {
	HashMap<String, Integer> map = new HashMap<>();
	map.put("철수", 90);
	map.put("영희", 100);
}
```
![[스크린샷 2025-05-15 오전 2.27.56.png]]


## Iterator
컬렉션의 모든 데이터 순회
```java
public static void main(String[] args) {
	ArrayList<String> list = new ArrayList<>();
	list.add("철수");
	list.add("영희");

	// 반복문을 통한 순회
	for (String s: list) {
		System.out.println(s);
	}
	// iterator를 통한 순회
	Iterator<String> it = list.iterator();
	while (it.hasNext()) {
		System.out.println(it.next());
	}
}
```
![[스크린샷 2025-05-15 오전 2.30.13.png]]


---
# [익명클래스, 람다와 스트림]
## 익명 클래스
한번만 사용되는 이름 없는 클래스
![[스크린샷 2025-05-15 오전 2.31.54.png]]


## 람다식
간결한 형태의 코드 묶음
```java
// 기본 메서드
public int add (int x, int y) {
	return x+y;
}

// 람다식 적용
(x, y) -> x+y
```
1. 접근제어자, 반환형, 이름 제거
2. -> 기호 삽입
3. 자료형 제거
4. 괄호, return 제거


## 함수형 인터페이스
람다식을 위한 인터페이스
```java
@FunctionalInterface
interface Calculator {
	int calculate(int x, int y);  // 하나의 추상 메소드
}

public static void main(String[] args) {
	Calculator add = (x, y) -> x+y; // 두 수를 더한 결과를 반환하는 람다식
	int result = add.calculate(2, 3); // 두 수를 더하는 동작 수행
	System.out.println("2+3 = " + result);
}
```


## 스트림
배열, 컬렉션 데이터를 효과적으로 처리
```java
public static void main(String[] args) {
	List<Integer> numbers = ArrayList.asLsit(1, 2, 3, 4, 5);
	numbers.stream()
		.filter(n-> n%2 == 0) // 짝수만 필터링
		.map(n-> n*2) // 각 요소 값을 2배로 변환
		.forEach(System.out::println); // 결과 출력
}
// 4, 8 출력
```

---

# [예외처리]
## 예외 발생시키키
의도적으로 예외 상황 만들기
![[스크린샷 2025-05-15 오전 2.47.39.png]]


## Try With Resource
리소스 관리를 편하게
```java
// 할당된 자원이 자동으로 해제되게 됨
try (자원 할당) {
	명령문;
} catch (변수) {
	예외처리;
}

// finally에서 자원을 해제하지 않아도 자동으로 해제되게 됨.
public static void main(String[] args) {
	try(FileWriter writer = new FileWriter("file.txt")) {
	writer.write("안녕?");
	} catch (Exception e) {
		System.out.println("문제 발생");
	}
}
```


## 사용자 정의 예외
Excption 클래스를 상속해서 만들 수 있음
```java
class MyException extends Exception {
	public MyException(String message) {
		super(message);
	}
}

public static void main(String[] args) {
	try {
		int age = -5;
		if (age<0) {
			throw new MyException("나이는 음수일 수 없습니다.");
		}
	} catch (MyException e) {
		System.out.println("문제 발생: " + e.getMessage());
	}
}
// 문제 발생: 나이는 음수일 수 없습니다.
```


## 예외 처리 미루기
#### throws
메소드를 호출한 곳에서 처리
![[스크린샷 2025-05-15 오전 2.57.24.png]]

---
# [쓰레드]
## Thread
여러 작업을 동시에 실행할 수 있다.
```java
class 클래스명 extends Thread {
	public void run() {
	}
}

public static void main(String[] args) {
	클래스명 thread = new 클래스명();
	thread.start(); // 새로운 쓰레드에서 run() 동작 수행
```
Thread를 상속 받기 때문에 Thread 외 다른 클래스 상속 불가능

## Join
- join 사용 안 했을 때.
![[스크린샷 2025-05-15 오전 3.03.10.png]]
![[스크린샷 2025-05-15 오전 3.03.40.png]]
- join 사용했을 때
![[스크린샷 2025-05-15 오전 3.04.31.png]]
![[스크린샷 2025-05-15 오전 3.04.16.png]]

## 다중 쓰레드
여러 쓰레드를 동시에 실행
![[스크린샷 2025-05-15 오전 3.06.03.png]]
![[스크린샷 2025-05-15 오전 3.06.22.png]]
실행 결과는 매번 달라진다.


### 동기화
공유된 자원에 동시에 접근하지 못하게 막는다.
```java
class SharedData {
	public int data = 0;
	// 한번에 하나의 쓰레드만 접근 가능
	synchronized public void increment() {
		data++;
	}
}
```


## Runnable
여러 작업을 동시에 실행할 수 있다.
```java
class 클래스명 implements Runnable {
	public void run() {
	}
}

public static void main(String[] args) {
	클래스명 runnable = new 클래스명();
	runnable.start(); // 새로운 쓰레드에서 run() 동작 수행
```
interface이기 때문에 다른 클래스 상속 가능

--- 


 