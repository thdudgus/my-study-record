1. 주어진 token set이 유효한지 결정한다.   
2. token stream의 문법적 구조를 나타내는 intermedeiate representation인 tree를 생성한다. (e.g., parse tree)   
<br>
유효한 token set을 결정하는 rule을 specify -> **프로그래밍 언어 rule에 기초하여 context-free grammar G를 만든다.**
유효한 token set과 유효하지 않은 token set을 구별 -> **주어진 token set이 context-free grammar로부터 derive될수 있는지 확인한다.**
=> **[[Context free grammar]]**   
regualr expression 대신에 Context-free grammar를 사용.   
![[Pasted image 20240415202433.png]]   

[[Terminals]]은 소문자   
[[Non-terminals]]은 대문자   
sequence of non-terminals, terminals, and  𝜖는 α, β, ω로 작성.   
<br>
효율적인 parsing을 위해 좋은 CFG를 만들어야 한다.   
- non-abiguous (모호하지 않게 하기가 매우 어려움...)      
- no left recursion (Bottm-up엔 필요 없음.) **=> right recursion으로 해결 가능.**     
- 각 non-terminals에 대해 하나의 production choice(특정 start symbol에서 시작하는) (Bottm-up에도 필요) **=> left factoring을 통해 해결 가능.**      

	top-down엔 위 세가지 모두 필요.

## Derivation
Leftmost (=>lm) : left-most non-terminal부터 교체, top-down parser에 사용   
Rightmost (=>rm) : right-most non-terminal부터 교체, bottom-up parser에 사용   
![[Pasted image 20240415210655.png]]   
<br>
### Token validation test   
Sentinel form : A가 G의 시작 심볼일 때, A=>* α라면, α는 G의 sentinel form   
Sentence :  α가 G의 sentinel form이고, G가 [[Terminals]]로만 이루어져 있다면,  α는 G의 sentence form   
Language : L(G) = {α | α is a sentence of G}   
<br>
input string이 L(G)에 속한다면(=sentence), 우리는 G에 valid하다고 할 수 있다.   
<br>
## Derivations to pasre trees
leaf nodes = terminals
non leaf nodes = non-terminals


**Ambiguity**
- dangling-else
- two or more parse tree

**Left recursion**   
non-terminal A가 A⇒+Aα일 때 left recursion에 빠질 수 있다.   
top-down은 왼쪽에서 오른쪽으로 derivation하기 때문에 왼쪽에 nonterminal이 있으면 loop에 빠질 수 있다.   
=> **right recursion**으로 다시 작성하면 된다!   
<br>
## Left factoring
어떤 production을 선택해야할지 모르기 때문에, 그냥 아무데나 갔다가 back tracking을 하게 되면 비효율적.   
따라서 이런 혼란을 막기 위해 left factoring을 함.   

![[Pasted image 20240415225754.png]]   

<br>
# Top-down parsing
leftmost derivation을 따른다.
LL parsing이라고도 부른다.
	left에서 right로 intput을 스캔.
	leftmost derivation.

### recursive descent


### predective parsing



### parsing table

First(A) : A가 유도할 수 있는 string의 첫 terminal.

Follow(A) : A 바로 뒤에 올 수 있는 **terminal의 set**
	Follow(A)는 ε을 포함한다.
	B -> αAβ라면, A의 뒤에 있는 β의 First에서 ε를 뺀 게 Follow(A)에 포함된다.
	B -> αAβ일 때, First(β)에 ε가 있거나 B -> αA라면 B의 Follow가 Follow(A)에 포함된다.


예시. 
![[Pasted image 20240425221413.png]]
<**First 구하기**> : 맨 마지막 non terminal부터 처음 non terminal로 올라가면서 구하기.
First(F) = { (, id }
First(T') = { \*, ε }
First(T) = First(F) = { (, id }   
	T에서 나오는 거에 terminal이 없고 non terminal FT'만 있음. 앞에(first) 있는 F의 First와 같음.
First(E') = { +,  ε }
First(E) = First(T) = { (, id }
	E에서 나오는 거에 terminal이 없고 non terminal TE'만 있음. 앞에(first) 있는 T의 First와 같음.



==terminal의 First는 terminal이라는 사실을 기억! Follow는 terminal을 찾으려고 하는 것...!==
<**Follow 구하기**> : Follow는 뒤에 따라올 수 있는 terminal set : 맨 처음 non terminal부터 구하기. 
1. Follow(A)면 나머지 A를 제외한 나머지 non terminal들이 만들어내는 것들에 A가 있는지 확인. 
2. non terminal이 있으면 First(그 non terminal)를 Follow(A)에 추가. 그 Fisrt에 ε가 있으면 ε를 빼서 Follow(A)에 추가시키고 대신에 그 non terminal의 시작 심볼 follow를 Follow(A)에 추가.
3. terminal이 있다면 그 teminal (First(terminal))이 Follow(A)에 속함.
4. 만약 ε이 있으면 (아무것도 없으면), 그냥 그 심볼의 Follow를 Follow(A)에 추가. 


Follow(E) = {$} ∪ Frist( ( ) ∪ Follow(E') = { $, ) }
	심볼E를 제외한 심볼들에서 non termianl E를 만들어낸다면, 그 non terminal E 뒤에 있는 terminal을 First(terminal)로 Follow(E)에 추가한다.
	non terminal이 없다면, 그 심볼의 Follow를 Follow(E)에 추가한다.
	
Follow(E') = Follow(E) = { $, ) }

Follow(T) = First(E') - { ε } ∪ Follow(E) ∪ Follow(T') = { +, $, ) }
	T를 만들어내는 심볼에서, T 뒤에 non terminal이 오기 때문에(terminal을 알기 위해) 그 non terminal E'의 First를 Follow(T)에 추가해줘야 하는데, First(E')엔 ε가 속해있으므로 ε를 빼서 추가해준다.
	T를 만들어낸 심볼에서, T 뒤에 아무것도 없기 때문에, 그 심볼 T'의 Follow를 Follow(T)에 추가해준다. Follow(T')는 T' 뒤에 뭐가 없어서 Follow(F)와 같음.
	
Follow(F) = Follow(T) = = { +, $, ) }

<br>
# Bottom-up parsing
##### token set을 자동적으로 validation하는 방법 = bottom-up parsing
## Shift-reduce parsing
**key idea1**
	ω를 두 substring으로 분할
	ω=α|β
	α는 이미 parser가 검사한 string, β는 아직 parser가 검사하지 않은 string

**key idea2**
- shift
spliter를 오른쪽으로 shift

	예시) XaY|bcd =>shift XaYb|cd
	
- reduce
[[suffix]]의 왼쪽 substring을 reduction 한다. 
그 왼쪽 substring은 production의 [[RHS]]와 일치한다.

	예시) Z -> Yb가 production일 때, XaYb|cd =>reduce XaZ|cd
여기서 suffix는 XaYb, 
 suffix의 left substring은 XaYb, aYb, Yb, b이다.
위 production의 RHS는(production의 결과string) Yb, 이 RHS와 일치하는 suffix의 left substring이 Yb이기 때문에 
XaZ|cd로 reduction되었다.
<br>
## two Confilcts
1. Shift-reduce confilct
각 단계에서, 우리는 shift할지, reduce할지 결정해아한다. 언제 해야하나?

2. Reduce-reduce conflict
reduction을 할 때, 우리는 어떤 reduction을 사용할지 결정해야 한다.
예를 들어, T->F\*T,     E->T가 존재하면, 
F*\T|인 상황에서 어떤 reductin을 사용해야 하나?

## => shift reducing 방식도 전형적인 bottom-up parsing 중 하나이므로 substring에 대한 handle이 존재할 것이고, 그 handle로부터 pruning하며, 최종적으로 root node를 찾아나가는 것이 목적
문제는 어떤 걸 handle로 정의할지.
[[viable prefix 정리]]


## 용어
위 두 문제를 어떻게 해결해야 하나?
#### [[Handle]]

#### [[Viable prefix]]




